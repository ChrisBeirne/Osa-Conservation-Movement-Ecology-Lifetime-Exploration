# Data cleaning - Mammals

All tracking devices come with errors, and each track must be checked visual and cleaned of outliers before analysis.

This page shows this process for each mammal within the project. It has been automated so that we always have access to a stardardised and cleaned locations database. 


```{r, include=F, eval=F}
# What animals do we need to do this for
tmp_mammal

```



### Tapirs

For the tapir collars we use the Telonics - TGW-4577-4 model, wioth data sent through the Iridium system.  

They have low voltage and mortality alerts. 

There are two types of location data these collars collect - regular GPS and QFP. QFP's are Quick Fix Positions and use less battery than a standard GPS fix. Units can be configured to collect GPS, QFP, or a mix of the two location types - we collect a mix. 

Our collars collect QFP's when there is *no GPS signal available*. 

`Succeded` = a successful GPS location
`Resolved QFP` = a successful QFP location
`Resolved QFP` = an uncertain QFP location (lower quality)
`Unresolved QFP` = A poor quality QFP 

Lets explore the implications of these different fix types for one individual - Juancito.

#### Juancito

```{r m1}
################################################################################
i <- 1
m1 <- mov_dat[mov_dat$name=="Juancito",]
#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)


#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))


trails <- st_read("shapefiles/OC_trails2.shp")
```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

To date we have `r nrow(m_df)` fixes from Juancito. Of those, they are of the following types. 

```{r m1a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m1b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)     

# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We can then explore how these different fix types introduce error into the locations:

*NOTE* ZOOM IN!

```{r m1c}

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)        
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 0.5,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Succeeded"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Succeeded"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup="Succeeded") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Resolved QFP"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Resolved QFP"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"], 
                   color="#f80", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Unresolved QFP"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Unresolved QFP"], 
                   color="#f00", stroke=F,radius=2,fillOpacity=1,
                   popup="Unresolved QFP (Uncertain)")%>% addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft") %>% 
    addLegend("topleft",
              labels = c("GPS", "Resolved QFP", "Uncertain QFP", "Unresolved QFP"),
              colors=c("black", "#1ff", "#f80", "#f00"),
            title = "Fix type",
            opacity=1)

```

So there is unreliability in all of the QFP estimates, but the GPS look great (not much spread). 

Lets explore the error around each type of fix (if it has an estimate present):

Only GPS data has an error in meters (max 127m):

```{r m1d}

boxplot(m_df$location_error_numerical~as.factor(m_df$gps_fix_type_raw))
```

QFP data has error in doplar estimates:
```{r m1e}
#boxplot(m_df$gps_hdop~as.factor(m_df$gps_fix_type_raw))
tmp <- m_df[m_df$gps_fix_type_raw!="Succeeded",]
fig <- plot_ly(tmp, y = ~gps_hdop, color = ~gps_fix_type_raw, type = "box")

fig
```

So we have a huge spread in error. Lets subset to anything with a hdop <10,and resolved. This substantially reduced the spread but still leaves a couple of issues - notable outliers. 

```{r m1f}

# Filter
filtered <- m1[m1$gps_fix_type_raw=="Succeeded" | ((m1$gps_hdop < 10) & m1$gps_fix_type_raw %in% c("Resolved QFP", "Resolved QFP (Uncertain)")),]

# Make a dataframe
filtered_df <- as.data.frame(filtered)

# move2
m2 = mt_as_move2(filtered, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)        
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Succeeded"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Succeeded"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup="Succeeded") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"], 
                   color="#f80", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Unresolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Unresolved QFP"], 
                   color="#f00", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We should also use ctmm (as in the vultures) to find errors:

```{r m1g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- m2[OUT$distance<8000,]
# Check the outlier is gone [Only if required]

m2 = clean_mammal[[i]]
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_mammal[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 

#i <- i + 1
```

#### Tuva

```{r m2}
################################################################################
i <- 2
m1 <- mov_dat[mov_dat$name=="Tuva",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
m_df$timestamp <- ymd_hms(m_df$timestamp)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))
```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

To date we have `r nrow(m_df)` fixes from Tuva. Of those, they are of the following types. 

```{r m2a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Which means even less "resolved" locations.

Plot of the raw data:

```{r m2b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)       
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We can then explore how these different fix types introduce error into the locations:

*NOTE* ZOOM IN!

```{r m2c}

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)         
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 0.5,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Succeeded"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Succeeded"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup="Succeeded") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Resolved QFP"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Resolved QFP"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"], 
                   color="#f80", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="Unresolved QFP"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="Unresolved QFP"], 
                   color="#f00", stroke=F,radius=2,fillOpacity=1,
                   popup="Unresolved QFP (Uncertain)")%>% addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft") %>% 
    addLegend("topleft",
              labels = c("GPS", "Resolved QFP", "Uncertain QFP", "Unresolved QFP"),
              colors=c("black", "#1ff", "#f80", "#f00"),
            title = "Fix type",
            opacity=1)

```

So there is unreliability in all of the QFP estimates, but the GPS look great (not much spread). 

Lets explore the error around each type of fix (if it has an estimate present):

Only GPS data has an error in meters (max 127m):

```{r m2d}

boxplot(m_df$location_error_numerical~as.factor(m_df$gps_fix_type_raw))
```

QFP data has error in dopler estimates:

```{r m2e}
#boxplot(m_df$gps_hdop~as.factor(m_df$gps_fix_type_raw))
tmp <- m_df[m_df$gps_fix_type_raw!="Succeeded",]
fig <- plot_ly(tmp, y = ~gps_hdop, color = ~gps_fix_type_raw, type = "box")

fig
```

So we have a huge spread in error. Lets subset to anything with a hdop <10,and resolved. This substantially reduced the spread but still leaves a couple of issues. 

```{r m2f}

# Filter
filtered <- m1[m1$gps_fix_type_raw=="Succeeded" | ((m1$gps_hdop < 10) & m1$gps_fix_type_raw %in% c("Resolved QFP", "Resolved QFP (Uncertain)")),]

# Make a dataframe
filtered_df <- as.data.frame(filtered)

# move2
m2 = mt_as_move2(filtered, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)         
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Succeeded"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Succeeded"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup="Succeeded") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"], 
                   color="#f80", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Unresolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Unresolved QFP"], 
                   color="#f00", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")%>% 
    addLegend("topleft",
              labels = c("GPS", "Resolved QFP", "Uncertain QFP", "Unresolved QFP"),
              colors=c("black", "#1ff", "#f80", "#f00"),
            title = "Fix type",
            opacity=1)
```

We should also use ctmm (as in the vultures) to find errors:

```{r m2g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=3, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- m2[OUT$distance<3000,]
# Check the outlier is gone [Only if required]

m2 = clean_mammal[[i]]
filtered_df <- as.data.frame(clean_mammal[[i]])
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)    
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Succeeded"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Succeeded"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup="Succeeded") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Resolved QFP (Uncertain)"], 
                   color="#f80", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>%
    addCircleMarkers(lng=filtered_df$location_long[filtered_df$gps_fix_type_raw=="Unresolved QFP"],
                   lat=filtered_df$location_lat[filtered_df$gps_fix_type_raw=="Unresolved QFP"], 
                   color="#f00", stroke=F,radius=2,fillOpacity=1,
                   popup="Resolved QFP (Uncertain)") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_mammal[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 
 
#i <- i + 1
```

### Carnivores

For carnivores we use Vectronic collars.

Large carnivores we have VERTEX Plus (GPS + ACC) and VERTEX Vision (GPS + ACC + Video)

#### Killa

VERTEX Plus collar. 

```{r m4}
################################################################################
i <- 4
m1 <- mov_dat[mov_dat$name=="Killa",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))
```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m4a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m4b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We can then explore how these different fix types introduce error into the locations:

*NOTE* ZOOM IN!

```{r m4c}

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 0.5,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="3D GPS Fix"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="3D GPS Fix"], 
                   color="#000", stroke=F,radius=2,fillOpacity=1,
                   popup=m_df$timestamp[m_df$gps_fix_type_raw=="3D GPS Fix"]) %>%
    addCircleMarkers(lng=m_df$location_long[m_df$gps_fix_type_raw=="3D valid GPS Fix"],
                   lat=m_df$location_lat[m_df$gps_fix_type_raw=="3D valid GPS Fix"], 
                   color="#1ff", stroke=F,radius=2,fillOpacity=1,
                   popup=m_df$timestamp[m_df$gps_fix_type_raw=="3D valid GPS Fix"]) %>%
    addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft") %>% 
    addLegend("topleft",
              labels = c("3D GPS Fix", "3D valid GPS Fix"),
              colors=c("black", "#1ff"),
            title = "Fix type",
            opacity=1)

```

We get doppler error estimates on these data, and they are all fairly small!:

```{r}
boxplot(m_df$gps_dop~m_df$gps_fix_type_raw, las=1)
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

No cleaning done to date:

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

```


We should also use ctmm (as in the vultures) to find errors:

```{r m4g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_columna = tmp_mammal$name[i])
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")
# 
# # Recreate the telemtry object
# m_df <- as.data.frame(clean_mammal[[i]])
# tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

#### Tico

VERTEX Plus collar. 

```{r m5}
################################################################################
i <- 5
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Tico",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))
```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m5a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m5b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We get doppler error estimates on these data, and they are all fairly small!:

```{r}
boxplot(m_df$gps_dop~m_df$gps_fix_type_raw, las=1)
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

No cleaning done to date:

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

```


We should also use ctmm (as in the vultures) to find errors:

```{r m5g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_columna = tmp_mammal$name[i])
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")
# 
# # Recreate the telemtry object
# m_df <- as.data.frame(clean_mammal[[i]])
# tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```

#### Coyunda

VERTEX Plus collar. 

```{r m6}
################################################################################
i <- 6
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Coyunda",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))
```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m6a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m6b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") %>% 
# Add shapefile for trails
addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We get doppler error estimates on these data, and they are all fairly small!:

```{r}
boxplot(m_df$gps_dop~m_df$gps_fix_type_raw, las=1)
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

No cleaning done to date:

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_columna = tmp_mammal$name[i])
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")
# 
# # Recreate the telemtry object
# m_df <- as.data.frame(clean_mammal[[i]])
# tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```


#### Shipetiari

VERTEX Plus collar. 

```{r m7}
################################################################################
i <- 7
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Shipetiari",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))

```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

Distance moved: 

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m7a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m7b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") 

#%>% 
# Add shapefile for trails
#addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We get doppler error estimates on these data, and they are all fairly small!:

```{r}
boxplot(m_df$gps_dop~m_df$gps_fix_type_raw, las=1)
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

No cleaning done to date:

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_columna = tmp_mammal$name[i])
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")
# 
# # Recreate the telemtry object
# m_df <- as.data.frame(clean_mammal[[i]])
# tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```


#### Kirari

VERTEX Plus collar. 

```{r m8}
################################################################################
i <- 8
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Kirari",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))

```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

Distance moved: 

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m8a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m8b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") 

#%>% 
# Add shapefile for trails
#addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```

We get doppler error estimates on these data, and they are all fairly small!:

```{r}
boxplot(m_df$gps_dop~m_df$gps_fix_type_raw, las=1)
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

No cleaning done to date:

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_columna = tmp_mammal$name[i])
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")
# 
# # Recreate the telemtry object
# m_df <- as.data.frame(clean_mammal[[i]])
# tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```

#### Kurá

VERTEX Plus collar. 

```{r m9}
################################################################################
i <- 9
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Kurá",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))

```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

Distance moved: 

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m9a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m9b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") 

#%>% 
# Add shapefile for trails
#addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

Remove the crazy outlier. 

```{r}
# Filter
filtered <- m2[m2$location_lat>6,]
# Make a dataframe
filtered_df <- as.data.frame(filtered)

#m2 = mt_as_move2(filtered, track_id_columna = tmp_mammal$name[i])

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

m2 = mt_as_move2(clean_mammal[[i]], track_id_column = "track", time_column= "timestamp")
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_mammal[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```


#### Katsímari

VERTEX Plus collar. 

```{r m10}
################################################################################
i <- 10
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Katsímari",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))

```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

Distance moved: 

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m10a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m10b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") 

#%>% 
# Add shapefile for trails
#addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

Remove the crazy outlier. 

```{r}
# Filter
filtered <- m2[m2$location_long<(-65),]
# Make a dataframe
filtered_df <- as.data.frame(filtered)

#m2 = mt_as_move2(filtered, track_id_columna = tmp_mammal$name[i])

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 
#plot(filtered)
clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

m2 = mt_as_move2(clean_mammal[[i]], track_id_column = "track", time_column= "timestamp")
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_mammal[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

#### Matsonsori

VERTEX Plus collar. 

```{r m11}
################################################################################
i <- 11
#tmp_mammal$name
m1 <- mov_dat[mov_dat$name=="Matsonsori",]

#head(m1)

# Make a dataframe
m_df <- as.data.frame(m1)
#head(m_df)
tmp <- data.frame(table(m_df$gps_fix_type_raw))

```

First observation: `r first(m_df$timestamp)`

Last observation:  `r last(m_df$timestamp)`

Active for: `r paste(round(as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1), "days")`

Distance moved: 

To date we have `r nrow(m_df)` fixes from `r print(tmp_mammal$name[i])`. Of those, they are of the following types. 

```{r m11a}
tmp$Percentage <- round(tmp$Freq/nrow(m_df),2)
tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling() 
```

Plot of the raw data:

```{r m11b}
# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_mammal$name[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") 

#%>% 
# Add shapefile for trails
#addPolylines(data = trails, color = "black", weight=2,opacity=1)    
  
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long,
                   lat=m_df$location_lat, 
                   color= "#FF10F0", radius=1) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")
```


The average number of fixes per day to date **`r round(nrow(m_df)/as.numeric(last(m_df$timestamp) - first(m_df$timestamp)),1)`** per day.

Those are distributed through time as follows:

```{r}
par(mfrow=c(1,1))
tmp2 <- m_df
tmp2$day <- substr(m_df$timestamp,1,10)
tmp2$day <- factor(tmp2$day, levels=as.character(seq(as.Date(first(tmp2$day)), as.Date(last(tmp2$day)), by="days")))

tmp2 <- tmp2 %>% group_by(day, .drop=FALSE) %>% summarise(fixes=n())

barplot(tmp2$fixes, names.arg=tmp2$day, las=2,
        cex.names=0.7)
```

Remove the crazy outlier. 

```{r}
# Filter
filtered <- m2
# Make a dataframe
filtered_df <- as.data.frame(filtered)

#m2 = mt_as_move2(filtered, track_id_columna = tmp_mammal$name[i])

```


We should also use ctmm (as in the vultures) to find errors:

```{r m6g}
# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
#m_df <- atl_filter_bounds(filtered_df, x = "location_long", 
#                              y = "location_lat", x_range = c(-88, -60), 
#                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(filtered_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(v=8, lty=2, col="red")
abline(h=0.5, lty=2, col="red")

# Delete extreme values 

clean_mammal[[i]] <- filtered
# Check the outlier is gone [Only if required]

# m2 = mt_as_move2(clean_mammal[[i]], track_id_column = "track", time_column= "timestamp")
# dat_lines <- m2 %>%
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# # Add the shapefiles
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>%
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_mammal[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_mammal$name[i]) 


```

**Current battery level:**

Be worried if it goes below 3000!

```{r}
p <- plot_ly(filtered_df, x = ~timestamp, y = ~tag_voltage, mode = 'line') %>% 
  layout(
    yaxis = list(
      range=c(2500,3500)
    )
  )  

p

```





### Upload clean data

```{r mammal_upload}
# Create.csv
mammal_stack <- mt_stack(clean_mammal)
tmp_csv <- as.data.frame(mammal_stack)
tmp_csv$geometry <- NULL
write.csv(tmp_csv, "tmp/mammal_clean.csv", row.names=F)
saveRDS(mov_dat, "tmp/mammal_stack.RDS")


# Create .RDS

#OC googledrive
drive_update(media = 'tmp/mammal_clean.csv',file=as_id("1DcZInxgArXdpQFslKljqlw21rsCXSBuQ"))
drive_update(media = 'tmp/mammal_stack.RDS',file=as_id("1MocaLuXKW51jJxXUlPPIwn39irZWs-Cg"))


#Chris' googledrive
#drive_update(media = 'tmp/mammal_clean.csv',file=as_id("1J5cE3CFitFbUUg1wA0GLYvONEcybSi56"))
#drive_update(media = 'tmp/mammal_stack.RDS',file=as_id("15KbO5FCX_VUNJKN53XX0TehtLtJntX9d"))


```



