
### Vulture summaries

We first regularize all of the data to one our intervals, then calculate distance moved.

#### King vultures

Average daily movement distance (1 hour intervals) across all individuals: 

```{r c10, echo=F, include=F, message=F, warning=F, eval=F}
# Create regular data
ids <- as.character(unique(trackId(mov_dat)))
#######
mov_regular <- list()

for(i in 1:length(ids))
{
  tmp <- interpolateTime(mov_dat[[as.character(ids[i])]], time=as.difftime(60,units="mins"), spaceMethod='greatcircle')
  tmp$distance_km <- c(NA, distance(tmp)/1000)
  mov_regular[[i]] <- as.data.frame(tmp)
  print(i)
}

mov_regular <- bind_rows(mov_regular)

# plot(test_df$location_long.1, test_df$location_lat.1, asp=1)
# plot(test_df$location_long, test_df$location_lat, asp=1)

kings <- unique(animals$local_identifier[animals$taxon_canonical_name=="Sarcoramphus papa"])

turkey <- unique(animals$local_identifier[animals$taxon_canonical_name=="Cathartes aura"])

yellow <- unique(animals$local_identifier[animals$taxon_canonical_name=="Cathartes melambrotus"])

black <- unique(animals$local_identifier[animals$taxon_canonical_name=="Coragyps atratus"])

mov_regular$date <- ymd(substr(mov_regular$timestamps,1,10))

tmp_res <- mov_regular %>% group_by(local_identifier, date) %>% summarize(obs=n(), daily_km=sum(distance_km))

#table(tmp_res$local_identifier)
# Correct the ecuador names
tmp_res$local_identifier[nchar(tmp_res$local_identifier)<3] <- paste0("X",tmp_res$local_identifier[nchar(tmp_res$local_identifier)<3])

# Rename
tmp_res$local_identifier[tmp_res$local_identifier=="X1"] <- ec_names$name[1]
tmp_res$local_identifier[tmp_res$local_identifier=="X2"] <- ec_names$name[2]
tmp_res$local_identifier[tmp_res$local_identifier=="X3"] <- ec_names$name[3]
tmp_res$local_identifier[tmp_res$local_identifier=="X4"] <- ec_names$name[4]

tmp_res <- tmp_res[tmp_res$obs>23,]
tmp_res$daily_km <- round(tmp_res$daily_km,1)

ymax <- max(tmp_res$daily_km, na.rm=T)
# Add in country
tmp <- dat[,c("name", "country")][duplicated(dat[,c("name", "country")])==F,]


tmp_res <- left_join(tmp_res, tmp, by=c("local_identifier"="name"))
```

```{r c11, eval=F}

table(tmp$country)
p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% kings,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~country, ncol = 3) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)

```

#### Turkey Vultures

```{r c12, eval=F}


p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% turkey,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~country, ncol = 3) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)

```

#### Greater Yellow-headed vultures

```{r c13, eval=F}

p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% yellow,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~country, ncol = 3) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)

```

#### Black vultures

```{r c14, eval=F}

p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% black,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~country, ncol = 3) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)
```

### Tag deployment summaries

```{r  c15, echo=F, message=F, warning=F}
tmp_col <- check_in_summary$days_since_checkin
tmp_col[tmp_col<12]<- 12

### Total locations Mean eobs battery power, eobs accuracy
tmp_sum <- dat %>% group_by(name) %>% dplyr::summarise(total_obs=n(), start_date=min(timestamp, na.rm=T), end_date=max(timestamp, na.rm=T))
tmp_sum$days_of_data <- round(difftime(tmp_sum$end_date, tmp_sum$start_date),0)
#colnames(dat)
tmp_sum$start_date <- substr(tmp_sum$start_date,1,10)

check_in_summary <- left_join(check_in_summary, tmp_sum)
check_in_summary$last_timestamp <- NULL

check_in_summary$locs_per_day <- round(check_in_summary$total_obs/as.numeric(check_in_summary$days_of_data),0)
check_in_summary$end_date <- substr(check_in_summary$end_date,1,10)


check_in_summary %>%
  kbl() %>%
  kable_styling()  %>%
    column_spec(4, color = "white",
              background = spec_color(tmp_col, begin=0,end = 0.7, direction=-1,
                                      option="D", scale_from = c(12,120)))%>%
  kableExtra::scroll_box(width = "100%")
```


# Vultures - Costa Rica  {.tabset}

### Point density

Below we show the logged point density accross our area of interest. Note, the extreme number of values on the Peninsula means we can't do a color ramp on the observation scale. 

```{r c16, echo=F, message=F, warning=F}
# Density raster
dat_sf_cr <- st_as_sf(tmp_cr, coords=c("location_long", "location_lat"), crs=4326)

# Write_for my files
#st_write(tmp_cr_shp, "C:/Users/cwbei/Dropbox/Osa Conservation/Data analysis/current_vulture_data/vulture_tracks.shp", append=F)



#bg <- ne_countries(scale = "large", country=c("Costa Rica", "Panama"), #returnclass = "sf")
#bg <- st_make_valid(bg)
#st_write(bg, "landmass.shp", append=F)
bg <- st_read("landmass.shp")

# make a fishnet grid over the countries
grd <- st_make_grid(dat_sf_cr, n = 200)
# visualize the grid
#plot(grd)


index <- which(lengths(st_intersects(grd, dat_sf_cr)) > 0)
# subset the grid to make a fishnet
fishnet <- grd[index]

# visualize the fishnet
#plot(fishnet)
#plot(bg, add=T, col="#f2f2f2", border=F)
#plot(fishnet,add=T)



test <- fishnet %>%   
  st_as_sf() %>% # cast to sf
  mutate(grid_id = row_number()) %>% # create unique ID
  st_join(dat_sf_cr) %>% # join the species dataset
  group_by(grid_id) %>% # group by the grid id
  count() 

tmp <- st_as_sf(test)

tmp$log.n <- log(tmp$n + 1)

ii <- cut(tmp$log.n, breaks = seq(min(tmp$log.n), max(tmp$log.n), len = 100), 
          include.lowest = TRUE)
## Use bin indices, ii, to select color from vector of n-1 equally spaced colors
colors <- inferno(99)[ii]

col_dat <- data.frame(values=seq(min(tmp$log.n), max(tmp$log.n), len = 100), colours=inferno(100))
col_dat$values_obs <- round(exp(col_dat$values),0)


m <- leaflet(tmp) %>%
  # Add a satellite image layer
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%  
    addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple")%>%  
  addPolygons(stroke=F, color=colors, fillOpacity=0.7, label=tmp$n, group = "Raster")
#?addPolygons  
m <- m %>%
      addLegend(position= "topright", colors=col_dat$colours[c(1,10,20,30,40,50,60,70,80,90,100)], 
                labels=c(1,col_dat$values_obs[c(10,20,30,40,50,60,70,80,90,100)]) ,opacity = 0.7, title = "point density") %>%    
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple","OS", "Satellite"),
        overlayGroups = c("Raster"),
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```

### Feeding clusters

The following map shows all of the vulture clusters.

We define a cluster where a bird stays for >80 minutes within 100m of its starting location. Provided it arrives after 08:00 am or before 16:00.  

### Costa Rica
```{r c17, eval=T, echo=F, message=F, warning=F, eval=F}
# Code derived from
# https://github.com/movestore/Daily-Rest-Sites
#library('maptools')
#library('ggmap')


# Subset to costa rica and vultures
sub_dat <- mov_dat[mov_dat$location_lat>0 ,]

sub_dat$speed <- unlist(lapply(move::speed(sub_dat),c, NA ))
sub_dat_df <- as.data.frame(sub_dat)
sub_dat_df <- left_join(sub_dat_df, animals[, c("tag_id", "name", "taxon_canonical_name")])


sub_dat_df <- sub_dat_df[order(sub_dat_df$name),]

# Add in icon column
sub_dat_df$icon <- sub(".*? ", "", sub_dat_df$taxon_canonical_name)




lfc <- do.call(st_sfc,
              lapply(split(sub_dat_df, sub_dat_df$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(name=levels(factor(sub_dat_df[,"name"])), geom=lfc))

#plot(st_geometry(dat_shp))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

# Bring in the colours from earlier
cr_cols <- tmp_cr[, c("name", "colours")]
cr_cols <- cr_cols[duplicated(cr_cols)==F,]
dat_shp <- left_join(dat_shp, cr_cols)
# Make shapefile of the tracks to add later

#plot(sub_dat_df$ground_speed, sub_dat_df$speed)
#plot(sub_dat_df$ground_speed, sub_dat_df$height_above_ellipsoid)

#plot(sub_dat, col=as.numeric(sub_dat$ground_speed<1)+1)
#plot(sub_dat[sub_dat$ground_speed<1,], add=T)



# Specifiy the settings

data=sub_dat
window="sunupdown"
upX=0
downX=0
speedvar="speed"
maxspeed=0.2

duration=1.2
radius=100


#rFunction <- function(data, window="all", upX=0, downX=0, speedvar="speed", maxspeed=NULL, duration=NULL, radius=NULL)
#{
  Sys.setenv(tz="America/Costa_Rica")
  
  names(data) <- make.names(names(data),allow_=FALSE)
  
  # add species info
  data.df <- as.data.frame(data)
  names(data.df) <- make.names(names(data.df),allow_=FALSE)
  #if (any(names(data.df)=="individual.taxon.canonical.name")) data@data$species <- data.df$individual.taxon.canonical.name
  data@data$species <- data.df$taxon.canonical.name
  
  speedx <- function(x) #input move object
  {
    N <- length(x)
    distVincentyEllipsoid(coordinates(x))/as.numeric(difftime(timestamps(x)[-1],timestamps(x)[-N],units="secs"))
  }

  n.all <- length(timestamps(data))
  data <- data[!duplicated(paste0(round_date(timestamps(data), "5 mins"), trackId(data))),]
  
    data.split <- move::split(data)
    data.ground <- foreach(datai = data.split) %do% {
        if (speedvar=="speed") 
        {
          if (length(datai)>1) #cannot calculated between-loc speed if only one location, therefore keep
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
 #           logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        } else if (speedvar %in% names(datai)) 
        {
          res <- datai[datai@data[,speedvar]<maxspeed | is.na(datai@data[,speedvar]),] # this allows also NA speed to be selected
#          logger.info("Your speed variable contains NA, these are kept in the data set of rest positions.")
        } else 
        {
#          logger.info("You have not selected a viable speed variable. Therefore the fallback between location speed is calculated.")
          if (length(datai)>1)
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
#            logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        }
        res
    }
    names(data.ground) <- names(data.split)
    data.ground <- moveStack(data.ground[unlist(lapply(data.ground, length) > 0)])
    
    # select night or day positions (use data.ground, call it "night")
    data.ground.split <- move::split(data.ground)
    data.night <- foreach(data.groundi = data.ground.split) %do% {
      #print(namesIndiv(data.groundi))
      sunupx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunrise", POSIXct.out=TRUE))$time + upX*60
      sundownx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunset", POSIXct.out=TRUE))$time + downX*60
      data.groundi@data <- cbind(data.groundi@data,sunupx,sundownx)

      ix <- which(is.na(sunupx) | is.na(sundownx))
      
      ix_ArcSum <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_ArcWin <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      ix_AntWin <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_AntSum <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      
      if (window=="all")
      {
        data.nighti <- data.groundi
        year <- as.POSIXlt(timestamps(data.nighti))$year+1900
        yday <- as.POSIXlt(timestamps(data.nighti))$yday
        data.nighti@data <- cbind(data.nighti@data,year,yday)
      } else
      {
        if (window=="sundownup") #night roosts
        {
          if (length(ix_ArcSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcSum,]
          }
          if (length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntSum,]
          }
          
          if (length(ix_ArcWin)>0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) and", length(ix_AntWin), " southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin,ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin,ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin,ix_AntWin)),]
          } else if (length(ix_ArcWin)>0 & length(ix_AntWin)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin)),]
          } else if (length(ix_ArcWin)==0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntWin)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)<=data.groundi$sunupx | timestamps(data.groundi)>=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          ynight <- yday
          
          ixx <- which(is.na(data.nighti$sundownx))
          if (length(ixx)>0)
          {
            ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]] <- ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]]+1
            
            # for Arctic/Antarctic nights the night goes from midday to midday, which depends on the location..
            midday_ixx <- solarnoon(coordinates(data.nighti[ixx]),timestamps(data.nighti[ixx]),POSIXct.out=TRUE)$time
            ynight[timestamps(data.nighti[ixx])>midday_ixx] <- ynight[timestamps(data.nighti[ixx])>midday_ixx]+1
          } else ynight[timestamps(data.nighti)>data.nighti$sundownx] <- ynight[timestamps(data.nighti)>data.nighti$sundownx]+1
          
          # adapt for New Year's Eve
          year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx]+1
          ynight[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- 0
          
          data.nighti@data <- cbind(data.nighti@data,year,yday,ynight)
        }
        
        if (window=="sunupdown") # day rests
        {
          if (length(ix_ArcWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcWin,]
          }
          if (length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntWin,]
          }
          
          if (length(ix_ArcSum)>0 & length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) and", length(ix_AntSum), " southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum,ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum,ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum,ix_AntSum)),]
          } else if (length(ix_ArcSum)>0 & length(ix_AntSum)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum)),]
          } else if (length(ix_ArcSum)==0 & length(ix_AntSum)>0)
          {
#            logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntSum)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)>=data.groundi$sunupx & timestamps(data.groundi)<=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          data.nighti@data <- cbind(data.nighti@data,year,yday)
        }
      }
      return(data.nighti)   
    }
    if (is(data.night,'Move')) data.night <- moveStack(data.night,forceTz="America/Costa_Rica") #force to movestack
    names (data.night) <- names(data.ground.split)
    data.night.nozero <- data.night[unlist(lapply(data.night, length) > 0)]
    
    {
      data.night <- moveStack(data.night.nozero)
      data.night.df <- as.data.frame(data.night)
      nacolx <- which(apply(data.night.df,2,function (x) all(is.na(x))))
      if (length(nacolx)>0) data.night.df.nna <- data.night.df[,-nacolx] else data.night.df.nna <- data.night.df #remove columns with all NA
      
      #write.csv(data.night.df.nna,file = paste0("data_rest_selectedTime.csv"),row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      #write.csv(data.night.df.nna,file = "data_rest_selectedTime.csv",row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      
      # save all rest positions if is rest by given definition (radius, duration), goes backwards for last night/day rest
      data.night.split <- move::split(data.night)
      
      if (window=="all")
      {
        prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      } else
      {
        if (window=="sundownup") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"ynight"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
        if (window=="sunupdown") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      }
      
      data.rest <- foreach(data.nighti = data.night.split) %do% {
#        logger.info(paste("Extracting rest sites of",namesIndiv(data.nighti)))
        data.resti.df <- data.frame(as.data.frame(moveStack(data.nighti)),coordinates(data.nighti))[0,] #empty df to fill, moveStack to keep trackId
        Nresti <- dim(data.resti.df)[2]
        names(data.resti.df)[(Nresti-1):Nresti] <- c("location.long","location.lat")
        
        year <- unique(data.nighti@data$year)
        for (k in seq(along=year))
        {
          
          data.nightik <- data.nighti[data.nighti@data$year==year[k],]
          
          if (window=="all")
          {
            night <- unique(data.nightik@data$yday)
          } else
          {
            if (window=="sundownup") night <- unique(data.nightik@data$ynight)
            if (window=="sunupdown") night <- unique(data.nightik@data$yday)
          }
          
          for (j in seq(along=night))
          {
            
            if (window=="all")
            {
              data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            } else
            {
              if (window=="sundownup") data.nightikj <- data.nightik[data.nightik@data$ynight==night[j],]
              if (window=="sunupdown") data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            }
            
            last <- Nikj <- length(data.nightikj)
            while (last>1) # as long as first night/day position is not the last
            {
              data.nightikj <- data.nightikj[1:last,]
              backdt <- as.numeric(difftime(timestamps(data.nightikj)[last],timestamps(data.nightikj)[-c(last:Nikj)],units="hours"))
              if (length(backdt)>=1) #changed this to allow for further away position (if in radius assume not moved), allows for worse resolution data
              {
                # note that here not yet checked that duration in site complete, later
                if (any(backdt<=duration)) 
                {
                  data.sel <- data.nightikj[c(which(backdt<=duration),last),] 
                  #data.sel$timestamp
                  data.rem <- data.nightikj[-c(which(backdt<=duration),last),]
                  #data.rem$timestamp
                  #plot(data.nightikj$location.long, data.nightikj$location.lat)
                  #points(data.sel$location.long, data.sel$location.lat, col="green")
                  #points(data.rem$location.long, data.rem$location.lat, col="red")
                  
                } else
                {
                  data.sel <- data.nightikj[(last-1):last,]
                  data.rem <- data.nightikj[-c((last-1):last),]
                  
                }
                m <- colMeans(coordinates(data.sel))
                dp0 <- distVincentyEllipsoid(m,coordinates(data.sel))
                p0 <- coordinates(data.sel)[min(which(dp0==max(dp0))),]
                dp1 <- distVincentyEllipsoid(p0,coordinates(data.sel))
                p1 <- coordinates(data.sel)[min(which(dp1==max(dp1))),]
                maxdist <- distVincentyEllipsoid(p0,p1)
                
                if (maxdist<radius)
                {
                  ## check if already longer at this rest site
                  mid <- midPoint(p0,p1)
                  #points(mid[1], mid[2], col="blue")
                  data.bef <- data.rem
                  if (length(data.bef)>=1)
                  {
                    dist.bef <- distVincentyEllipsoid(mid,coordinates(data.bef))
                    if (any(dist.bef>radius))
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      
                    } else 
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration),which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration),which(backdt<=duration),last),]
                    }
                  } else 
                  {
                    data.selx <- data.sel
                    data.remx <- data.rem
                  }
                  
                  data.selx.df <- data.frame(as.data.frame(moveStack(data.selx)),coordinates(data.selx))
                  # Check what is in there
                  #points(data.selx.df$location.long, data.selx.df$location.lat, col="yellow", pch=19)
                  # looks good
                  
                  Nselx <- dim(data.selx.df)[2]
                  names(data.selx.df)[(Nselx-1):Nselx] <- c("location.long","location.lat")
                  
                  time0 <- min(timestamps(data.selx))
                  timeE <- max(timestamps(data.selx))
                  durx <- as.numeric(difftime(timeE,time0,unit="hour"))
                  radx <- max(distVincentyEllipsoid(mid,coordinates(data.selx)))
                  
                  if (durx>=duration & radx<=radius) #added this condition to only save rest sites of given duration (if this condition is left out also rest site with shorter duration are given back)
                  {
                    data.resti.df <- rbind(data.resti.df,data.selx.df)
                    #points(data.resti.df$location.long, data.resti.df$location.lat, pch="x")
                    
                    
                    if (window=="all")
                    {
                      prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species,"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    } else
                    {
                      if (window=="sundownup") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"ynight"=data.selx.df$ynight[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                      if (window=="sunupdown") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    }
                  }
                  
                  
                  data.nightikj <- data.remx
                  #points(data.nightikj$location.long, data.nightikj$location.lat, pch="w")
                  
                  last <- Nikj <- length(data.nightikj) #this can be zero, will be stop indication in while() condition
                  
                } else last <- last-1 #shift one time step
              } else last <- last-1 # shift one time step also if not enough data in previous Xh time frame
            } #while
          } #for j
        } #for k
        if (dim(data.resti.df)[1]>0) 
        {
          o <- order(data.resti.df$timestamp)
          data.resti <- move(x=data.resti.df$location.long[o],y=data.resti.df$location.lat[o],time=as.POSIXct(data.resti.df$timestamp[o]),data=data.resti.df[o,],sensor=data.resti.df$sensor[o],animal=data.resti.df$trackId[o])
          
        } else data.resti <- NULL
      }
      names(data.rest) <- names(data.night.split)
      data.rest.nozero <- data.rest[unlist(lapply(data.rest, length) > 0)] #remove IDs with no data
      
      if (length(data.rest.nozero)==0) 
      {
#        logger.info("Your output file contains no positions. No csv overview and plot saved. Return NULL.")
        result <- NULL
      } else 
      {
        result <- moveStack(data.rest.nozero)
        #write.csv(prop.rest.df,file = paste0("rest_overview.csv"),row.names=FALSE) #csv artefakt
        #write.csv(prop.rest.df,file = "rest_overview.csv",row.names=FALSE)
        
        
                #map <- get_map(bbox(extent(data)),source="stamen",force=TRUE)
        
        #data.df <- data.frame(coordinates(data),as.data.frame(moveStack(data)))
        #names(data.df)[1:2] <- c("location.long0","location.lat0")
        
        #out <- ggmap(map) +
        #  geom_path(data=data.df,aes(x=location.long0,y=location.lat0,group=trackId),colour="blue") +
        #  geom_point(data=prop.rest.df,aes(x=rest.mean.long,y=rest.mean.lat),colour="red",size=3)

                #ggsave(out, file = paste0("rest_sites_onTracks.pdf"))
        
        # note that all timestamps are UTC!
      }
    }
  #}
  #return(result)
#test <- as.data.frame(result)
#plot(result)
#str(test)

#
clus_res <- prop.rest.df


# Convert the timestamps
clus_res$timestamp.first <- with_tz(ymd_hms(clus_res$timestamp.first), tz="America/Costa_Rica")
clus_res$timestamp.last <- with_tz(ymd_hms(clus_res$timestamp.last), tz="America/Costa_Rica")
clus_res$code <- paste0(toupper(substr(clus_res$local.identifier,1,3)),"_", substr(clus_res$timestamp.first,12,13),substr(clus_res$timestamp.first,3,4),substr(clus_res$timestamp.first,6,7),substr(clus_res$timestamp.first,9,10))  

# # Leaflet the data and add the output
# cols <- c("red", "blue")
# 
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat$ground_speed<1)+1]) 
# 
#  m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat_df$speed<0.1)+1]) 
# 
# m 
#  
#    
#   m <- m %>%
#         addCircleMarkers(lng=tmp$rest.mean.long,
#                          lat=tmp$rest.mean.lat, 
#                          popup=paste("duration =",tmp$rest.duration, "npos =",tmp$rest.nposi),
#                          fillOpacity = 0.3, opacity = 0.7, radius=4, color="orange") 
# 
# m  
 
# Try and define roost sites

clus_res$hour<- as.numeric(substr(clus_res$timestamp.first,12,13))


clus_res$type <- NA
clus_res$type[clus_res$hour<8] <- "night_roost"
clus_res$type[clus_res$hour>15] <- "night_roost"

clus_res$type[as.numeric(substr(clus_res$timestamp.first,12,13))>7 &  as.numeric(substr(clus_res$timestamp.first,12,13))< 16] <- "potential_feeding"

#boxplot(clus_res$rest.duration~clus_res$type)


#hist(clus_res$rest.duration[clus_res$type=="potential_feeding"])

#summary(clus_res$rest.duration[clus_res$type=="potential_feeding"])

clus_res$type_col <- NA
clus_res$type_col[clus_res$type=="potential_feeding"] <- "yellow"
clus_res$type_col[clus_res$type!="potential_feeding"] <- "red"



m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addCircleMarkers(lng=clus_res$rest.mean.long,
                         lat=clus_res$rest.mean.lat, 
                         popup=paste("name"=clus_res$local.identifier, 
                                     "<br>duration =",round(clus_res$rest.duration,1), "h", 
                                     "<br>time =",substr(clus_res$timestamp.first, 12,16), "-", substr(clus_res$timestamp.last, 12,16),
                                     "<br>npos =",clus_res$rest.nposi, " Radius =" ,round(clus_res$rest.radius,1),"m",
                                     "<br>lon =" ,round(clus_res$rest.mean.lon,6)  , "lat =", round(clus_res$rest.mean.lat,6),
                                     "<br>code =", clus_res$code) 
                                     ,
                          fillOpacity = 0.8, opacity = 0.7, radius=2, stroke=F, fillColor = clus_res$type_col)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
      )  %>% 
    addLegend(position="topright", labels=c("potential feeding", "likely roost"), colors=c("yellow","red"), title="Cluster age")


  m

 

  # I could link last nighttime point with mporning clusters
  
  
```


### Habitat use

```{r c18, eval=F}
# Convert the point shapefile into vect format and extract the habitat type for each bird

habitat <- rast("vulture_habitat_ESA_10m_aoi.tif")
habitat_key <- read.csv("ESA_v2_labels.csv", header=T)
# Update colour table
coltb <- data.frame(value=as.numeric(habitat_key$NB_LAB), col=paste0("#", habitat_key$rgb))
coltab(habitat) <- coltb
#plot(habitat)


cr_terra_points <- vect(dat_sf_cr) 

tmp <- extract(habitat, cr_terra_points)

dat_sf_cr$NB_LAB <- tmp$`ESACCI-global-10m_merged`
dat_sf_cr <- left_join(dat_sf_cr, habitat_key)

cr_hab_dat <- as.data.frame(dat_sf_cr)

ind_res <- cr_hab_dat %>% group_by(local_identifier, LCCOwnLabel) %>% 
summarise(count=n())

ind_res <- as.data.frame(ind_res)

#ind_res$LCCOwnLabel

ind_res_wide <- reshape(ind_res, idvar="local_identifier", timevar="LCCOwnLabel", direction="wide")

# MAkes NA's 0
ind_res_wide[is.na(ind_res_wide)]<- 0
# up[date column names
colnames(ind_res_wide)[2:ncol(ind_res_wide)] <- c("sparse_veg", "urban", "cropland", "grassland", "wetland", "mangrove","water", "trees", "shrubs" )

# Count total opbs
tmp <- rowSums(ind_res_wide[,2:ncol(ind_res_wide)])
ind_res_prop <- ind_res_wide
ind_res_prop[,2:ncol(ind_res_wide)] <- round(ind_res_wide[,2:ncol(ind_res_wide)]/tmp,4)

colSums(ind_res_prop[,2:ncol(ind_res_prop)])

ind_res_prop <- ind_res_prop[order(ind_res_prop$trees),]
ind_res_prop$local_identifier <- factor(ind_res_prop$local_identifier, levels=unique(ind_res_prop$local_identifier))
#
fig <- plot_ly(ind_res_prop, x = ~local_identifier, y = ~trees, name = 'forest', type = 'bar')
fig <- fig %>% add_trace(y = ~grassland, name = 'grassland')
fig <- fig %>% add_trace(y = ~water, name = 'water')
fig <- fig %>% add_trace(y = ~urban, name = 'urban')
fig <- fig %>% add_trace(y = ~mangrove, name = 'mangrove')
fig <- fig %>% add_trace(y = ~wetland, name = 'wetland')
fig <- fig %>% add_trace(y = ~cropland, name = 'cropland')
fig <- fig %>% add_trace(y = ~sparse_veg, name = 'sparse veg')

fig <- fig %>% layout(yaxis = list(title = 'Proportion'), barmode = 'stack')
fig
```

# Mammal data
```{r c18a, eval=F}

# Ocelot
tmp <-getMovebankAnimals(study=2526574641,login=loginStored)
# Tapir
tmp2 <- getMovebankAnimals(study=1954804459,login=loginStored)
# Carnivores
tmp3 <- getMovebankAnimals(study=2957292408,login=loginStored)

mammals <- rbind(tmp,tmp2, tmp3)

# For some reason they are duplicated
mammals[duplicated(mammals)==F,]
# They vary by the field "sensor_type_id"
mammals <- mammals[mammals$sensor_type_id==653 & is.na(mammals$sensor_type_id)==F,]

# Clean up the name
mammals$animalName <- paste0(sub('\\_.*', '', mammals$animalName), "_", sub('\\ .*', '', mammals$taxon_canonical_name))
mammals$name <- sub('\\_.*', '', mammals$animalName)

# Sort date objects
mammals$timestamp_start <- ymd_hms(mammals$timestamp_start)
mammals$timestamp_end <- ymd_hms(mammals$timestamp_end)
```

### Pardo

```{r c18b, eval=F}
tmp <- getMovebankData(study=2526574641, login=loginStored,  removeDuplicatedTimestamps=TRUE)
# Remove obvious outliers
tmp <- tmp[tmp$location_lat<8.6,]
```

We recieved `r nrow(tmp)` locations from Pardos collar, covering a time span of `r round((min(tmp$timestamp) %--% max(tmp$timestamp))/ddays(1),0)` days. 

```{r c18c, eval=F}
#plot(tmp)
#summary(tmp@data$location_error_numerical)

tmp_df <- as.data.frame(tmp)

lfc <- st_linestring(as.matrix(tmp_df[,c("location_long", "location_lat")]))

tmp_sf <- st_as_sf(tmp, coords=c(tmp_df$location_long, tmp_df$location_long))

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%  
      addPolylines(data = lfc, weight=1,opacity=0.5) %>%
      # Add survey location
      addCircleMarkers(lng=tmp_sf$location_long,
                         lat=tmp_sf$location_lat, radius=1) %>% 
      #addLegend(position= "topright", colors=tmp_cr_shp$colours, 
       #         labels=names ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topright", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addFullscreenControl()
  
m 
```

### Tapirs

```{r c19, eval=F}
#Tapir
tmp2 <- getMovebankData(study=1954804459, login=loginStored,  removeDuplicatedTimestamps=TRUE)
# Remove the obvious outliers
tmp2 <- tmp2[tmp2$location_lat>8,]
tmp2 <- tmp2[tmp2$location_lat<8.5,]

tmp3 <- as.data.frame(tmp2)
tmp3 <- tmp3[order(tmp3$local_identifier),]

# plot(tmp3$location_long, tmp3$location_lat, asp=1)
# points(tmp3$location_long[is.na(tmp3$location_error_numerical)==T],tmp3$location_lat[is.na(tmp3$location_error_numerical)==T] , col="red")
# points(tmp3$location_long[is.na(tmp3$location_error_numerical)==F],tmp3$location_lat[is.na(tmp3$location_error_numerical)==F] , col="black")



lfc <- do.call(st_sfc,
              lapply(split(tmp3, tmp3$local_identifier),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp3_shp <- st_sf(data.frame(name=levels(factor(tmp3[,"local_identifier"])), geom=lfc))

errors <- tmp3[tmp3$gps_hdop>2000 & is.na(tmp3$gps_hdop)==F,]

# Create a summary
mov_dist <- list()
i <-1

for(i in 1:length(levels(tmp2@trackId)))
{
  tmp <- interpolateTime(tmp2[[as.character(levels(tmp2@trackId)[i])]], time=as.difftime(60,units="mins"), spaceMethod='greatcircle')
  tmp$distance_km <- c(NA, distance(tmp)/1000)
  mov_dist[[i]] <- as.data.frame(tmp)
  #print(i)
}
mammal_df <- bind_rows(mov_dist)
#plot(mammal_df$location_long, mammal_df$location_lat)


summary <- tmp3 %>% group_by(local_identifier) %>% summarize(n_obs=n(), first_day=substr(min(timestamp),1,10), last_day=substr(max(timestamp),1,10))

tmp <- mammal_df %>% group_by(local_identifier) %>% summarize(obs_days=round(n()/24,0), dist_moved_km=round(sum(distance_km, na.rm=T),0))

summary <- left_join(summary, tmp)
kbl(summary)%>%
  kable_styling()
```

And a map of the locations

```{r c20, eval=F}
ids <- tmp3_shp$name
names <- tmp3_shp$name
cols <- c("red", "blue")
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
i <-1
  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp3_shp[i,], color = cols[i], group = ids[i], weight=1,opacity=0.4)         %>%
        addCircleMarkers(lng=tmp3$location_long[tmp3$local_identifier==ids[i]],
                         lat=tmp3$location_lat[tmp3$local_identifier==ids[i]], 
                         popup=paste(tmp3$timestamp[tmp3$local_identifier==ids[i]]),
                         fillOpacity = 1, opacity = 0.5, radius=2, color = cols[i], group = ids[i], stroke=F) 
  }

  m <- m %>%
       addLegend(colors = c("red", "blue"), labels=c("Juancito" ,"Tuva"), opacity = 1)

  
 # p <- m  %>%
  #      addCircleMarkers(lng=errors$location_long,
  #                       lat=errors$location_lat, 
  #                       popup=paste(errors$timestamp))
    
m 

#p

```

### Carnivores

```{r c21, eval=F}
# cARNIVORES
tmp2 <- getMovebankData(study=2957292408, login=loginStored,  removeDuplicatedTimestamps=TRUE)
#plot(tmp2)

# plot(tmp2)
# plot(tmp2[is.na(tmp2$location_error_numerical)==T,], col="red", add=T)
# table(is.na(tmp2$location_error_numerical))


tmp3 <- as.data.frame(tmp2)
tmp3 <- tmp3[order(tmp3$local_identifier),]

high_qual <- tmp3[is.na(tmp3$location_error_numerical)==F,]

#summary(tmp3$location_error_numerical)
# table(is.na(tmp3$location_error_numerical))

lfc <- do.call(st_sfc,
              lapply(split(tmp3, tmp3$local_identifier),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp3_shp <- st_sf(data.frame(name=levels(factor(tmp3[,"local_identifier"])), geom=lfc))

#errors <- tmp3[tmp3$gps_hdop>2000 & is.na(tmp3$gps_hdop)==F,]

# Create a summary
mov_dist <- list()
i <-1


#for(i in 1:length(tmp2@idData$local_identifier))
#{
  tmp <- interpolateTime(tmp2, time=as.difftime(60,units="mins"), spaceMethod='greatcircle')
  tmp$distance_km <- c(NA, distance(tmp)/1000)
  mov_dist[[i]] <- as.data.frame(tmp)
  #print(i)
#}
mammal_df <- bind_rows(mov_dist)
#plot(mammal_df$location_long, mammal_df$location_lat)


summary <- tmp3 %>% group_by(local_identifier) %>% summarize(n_obs=n(), first_day=substr(min(timestamp),1,10), last_day=substr(max(timestamp),1,10))

tmp <- mammal_df %>% group_by(local_identifier) %>% summarize(obs_days=round(n()/24,0), dist_moved_km=round(sum(distance_km, na.rm=T),0))

summary <- left_join(summary, tmp)
kbl(summary)%>%
  kable_styling()
```

And a map of the locations

```{r c22, eval=F}
ids <- tmp3_shp$name
names <- tmp3_shp$name
cols <- c("blue")
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
i <-1
  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp3_shp[i,], color = cols[i], group = ids[i], weight=1,opacity=0.4)         %>%
        
        addCircleMarkers(lng=tmp3$location_long[tmp3$local_identifier==ids[i]],
                         lat=tmp3$location_lat[tmp3$local_identifier==ids[i]], 
                         popup=paste(tmp3$timestamp[tmp3$local_identifier==ids[i]]),
                         fillOpacity = 1, opacity = 0.5, radius=2, color = "blue", group = ids[i], stroke=F) %>% 
      addCircleMarkers(lng=high_qual$location_long[high_qual$local_identifier==ids[i]],
                         lat=high_qual$location_lat[high_qual$local_identifier==ids[i]], 
                         popup=paste(high_qual$timestamp[high_qual$local_identifier==ids[i]]),
                         fillOpacity = 1, opacity = 0.5, radius=2, color = "red", group = ids[i], stroke=F) 
  }

  m <- m %>%
       addLegend(colors = c("red", "blue"), labels=c("High quality" ,"All locations"), opacity = 1)

                  
    
m 



```



```{r, eval=F}
# Presentation figures (run the script files first)


i <- 18
# Santa
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "red",
                   # The line properties
                   weight = 1,opacity = 1,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                          y = "location_lat", x_range = c(-88, -60), 
                          y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 



GUESS <- ctmm.guess(tel)
FIT <- ctmm.fit(tel)
summary(FIT)
UD <- akde(tel,FIT)
plot(tel,UD=UD)


i <- 24
# Jatayu
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "purple",
                   # The line properties
                   weight = 1,opacity = 1,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")



#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                          y = "location_lat", x_range = c(-88, -60), 
                          y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 



GUESS <- ctmm.guess(tel)
FIT <- ctmm.fit(tel)
summary(FIT)
UD <- akde(tel,FIT)
plot(tel,UD=UD)



#########################################################################
#

flying <- dat[dat$ground_speed>4 & dat$ground_speed<25 & dat$country=="costa_rica",]

hist(flying$ground_speed)

######
# Ground speed
bw <- 1
spacer<-3
summary(flying$ground_speed)
table(flying$taxon_canonical_name)


flying %>% group_by(taxon_canonical_name) %>% summarise(mean(ground_speed))



# TV
tmp <- flying$ground_speed[flying$taxon_canonical_name=="Cathartes aura"]
h <- hist(tmp, breaks=seq(4,26, bw), freq=F, plot=F)

# BV
tmp1 <- flying$ground_speed[flying$taxon_canonical_name=="Coragyps atratus"]
h1 <- hist(tmp1, breaks=seq(4,26, bw), freq=F, plot=F)

# KV
tmp2 <- flying$ground_speed[flying$taxon_canonical_name=="Sarcoramphus papa"]
h2 <- hist(tmp2, breaks=seq(4,26, bw), freq=F, plot=F)

# TV plot
h$density = h$count/sum(h$count)
plot(h, freq=F, las=1, ylab="Proportion of locations",
     xaxt="n", main="", col=rgb(227/255,33/255,33/255, 0.5),
     xlab="Ground speed (m/s)", xaxs="i", yaxs="i")
axis(1,h$mids[seq(1, length(h$mids), by=spacer)], at=h$mids[seq(1, length(h$mids), by=spacer)],cex.axis=0.8 )
axis(1, at=c(-1000,10000))
axis(2, at=c(-1000,10000))
abline(v=8.35, lty=1, col=rgb(227/255,33/255,33/255), lwd=3)

# BV
h1$density = h1$count/sum(h1$count)
plot(h1, freq=F, las=1, ylab="Proportion",
     xaxt="n", main="", col=rgb(0/255,0/255,0/255, 0.5), add=T)
abline(v=10.4, lty=1, col=rgb(0/255,0/255,0/255), lwd=3)

#KV
h2$density = h2$count/sum(h2$count)
plot(h2, freq=F, las=1, ylab="Proportion",
     xaxt="n", main="", col=rgb(162/255,139/255,169/255, 0.5), add=T)
abline(v=11.8, lty=1, col=rgb(162/255,139/255,169/255), lwd=3)


# Calculate flight ehight?



# Uplaod to https://www.unavco.org/software/geodetic-utilities/geoid-height-calculator/geoid-height-calculator.html
tmp <- flying[,c("location_lat", "location_long")]
tmp$elevation <- 0
#write.csv(tmp, "lat_long.csv", row.names=F)
# Read in the results
tmp <- read.csv("geoid_height_2023-11-08.csv", header=T)
flying$asl_m <- flying$height_above_ellipsoid -   tmp$Geoid.Height..m.



# Now get a DEM
library(elevatr)
library(sf)
flying <- flying[is.na(flying$location_lat)==F,]
vul.sf <- as_Spatial(st_as_sf(flying, coords=c("location_long", "location_lat"), crs=4326))
prj_dd <- "EPSG:4326"

# With as much zoom as I can handle
elev_tmp <- get_elev_point(vul.sf, prj = prj_dd, src = "aws", z=13)
flying$height_m <- flying$asl_m - elev_tmp$elevation



flying$height_m[flying$height_m<0] <- 0
flying <- flying[flying$height_m<1500,]
summary(flying$height_m)
hist(flying$height_m)

flying %>% group_by(taxon_canonical_name) %>% summarise(mean(height_m))

bw <- 50
spacer<-5
summary(flying$height_m)
# GYV
tmp <- flying$height_m[flying$taxon_canonical_name=="Cathartes aura"]
h <- hist(tmp, breaks=seq(0,1500, bw), freq=F, plot=F)

tmp1 <- flying$height_m[flying$taxon_canonical_name=="Coragyps atratus"]
h1 <- hist(tmp1, breaks=seq(0,1500, bw), freq=F, plot=F)


tmp2 <- flying$height_m[flying$taxon_canonical_name=="Sarcoramphus papa"]
h2 <- hist(tmp2, breaks=seq(0,1500, bw), freq=F, plot=F)

# TV
h$density = h$count/sum(h$count)
plot(h, freq=F, las=1, ylab="Proportion of locations",
     xaxt="n", main="", col=rgb(227/255,33/255,33/255, 0.5),
     xlab="Flight height (m)", xaxs="i", yaxs="i")
axis(1,h$mids[seq(1, length(h$mids), by=spacer)], at=h$mids[seq(1, length(h$mids), by=spacer)],cex.axis=0.8 )

axis(1, at=c(-1000,10000))
axis(2, at=c(-1000,10000))
abline(v=94, lty=1, col=rgb(227/255,33/255,33/255), lwd=3)
#BV
h1$density = h1$count/sum(h1$count)
plot(h1, freq=F, las=1, ylab="Proportion",
     xaxt="n", main="", col=rgb(0/255,0/255,0/255, 0.5), add=T)
abline(v=183, lty=1, col=rgb(0/255,0/255,0/255), lwd=3)

#KV
h2$density = h2$count/sum(h2$count)
plot(h2, freq=F, las=1, ylab="Proportion",
     xaxt="n", main="", col=rgb(162/255,139/255,169/255, 0.5), add=T)
abline(v=321, lty=1, col=rgb(162/255,139/255,169/255), lwd=3)

```

