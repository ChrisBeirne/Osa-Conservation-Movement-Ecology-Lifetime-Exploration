---
title: "Osa Conservation: Movement report"
author:
  - Chris Beirne
site: bookdown::test-bookdown
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
editor_options: 
  chunk_output_type: console
---

# Device Status

This document summarizes the movement locations for all active devices within Osa Conservation's movement ecology project. 

```{r c01, echo=F, message=F, include=F}
knitr::opts_chunk$set(echo = FALSE, message=F, warning=F)

library(rgdal) 
library(move)
library(dplyr)
library(leaflet)
library(units)
library(sf)
library(viridis)
library(kableExtra)
library(lubridate)
library(plotly)
## Load packages for google drive ----
library(googledrive)
library(purrr)
library(readxl)
library(geosphere)
library(foreach)
library(maptools)
library(leaflet.opacity)
library(leaflet.extras)
#library(rnaturalearth)
library(terra)
library(ggplot2)

options(googledrive_quiet = TRUE)

# For when the trapping effort file is sorted
googledrive::drive_auth(path = Sys.getenv("GOOGLE_AUTHENTICATION_CREDENTIALS"))

# ## Find Google Drive folder 'Centre Circle Data & Info'
# data_path <- "data" 
# dir.create(data_path) 

# Get the habitat raster 
#drive_download(as_id("1zDN1uh_ioOdIFATp9Q18bYTukygNo52t"), overwrite=T)

habitat <- rast("vulture_habitat_ESA_10m_aoi.tif")
habitat_key <- read.csv("ESA_v2_labels.csv", header=T)
# Update colour table
coltb <- data.frame(value=as.numeric(habitat_key$NB_LAB), col=paste0("#", habitat_key$rgb))
coltab(habitat) <- coltb
#plot(habitat)
  
# Import passcodes
MOVE_PASS <- Sys.getenv("MOVEBANK_PASSWORD")
MOVE_USE  <- Sys.getenv("MOVEBANK_USERNAME")

loginStored <- movebankLogin(username=MOVE_USE, 
                             password=MOVE_PASS)

# Get animals
# Vultures
animals <-getMovebankAnimals(study=1573471517,login=loginStored)

# For some reason they are duplicated
animals[duplicated(animals)==F,]
# They vary by the field "sensor_type_id"
animals <- animals[animals$sensor_type_id==653 & is.na(animals$sensor_type_id)==F,]

# Clean up the name
animals$animalName <- paste0(sub('\\_.*', '', animals$animalName), "_", sub('\\ .*', '', animals$taxon_canonical_name))
animals$name <- sub('\\_.*', '', animals$animalName)

# Sort date objects
animals$timestamp_start <- ymd_hms(animals$timestamp_start)
animals$timestamp_end <- ymd_hms(animals$timestamp_end)

# Get all the data

# Vultures
mov_dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)

#Add the names
mov_dat$name <- trackId(mov_dat)


# Convert timezone
mov_dat$timestamp <- with_tz(timestamps(mov_dat), tz="America/Costa_Rica")

# all data
#dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)

# Convery move stack to dataframe
dat <- as.data.frame(mov_dat)

# Convert dat to costa rica time
dat$timestamp <- with_tz(dat$timestamp, tzone = "America/Costa_Rica")

# Add the location data
dat <- left_join(dat, animals[, c("tag_id", "animalName")])
# Sort the names out

dat$animalName <- sub('\\_.*', '', dat$animalName)
# Add in the taxonomic group
dat$animalName <- paste0(dat$animalName, "_", sub('\\ .*', '', dat$taxon_canonical_name))

# Current time and date

t <- now("America/Costa_Rica") 


# # Setup the leaflet icon
# leafIcons <- icons(
#   iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small1.png",
#   iconWidth = 38, iconHeight = 40,
#   iconAnchorX = 22, iconAnchorY = 39,
#   shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
#   shadowWidth = 38, shadowHeight = 30,
#   shadowAnchorX = 4, shadowAnchorY = 39
# )
# #?iconList()

papa <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/king_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

aura <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/turk_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

mela <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/yhv_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

pardalis <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/ocelot.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39)

bairdii <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/tapir.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39)

iconSet <- iconList(aura= aura,
                    papa =papa,
                    melambrotus = mela,
                    pardalis = pardalis,
                    bairdii = bairdii)

dat$icon <- sub(".*? ", "", dat$taxon_canonical_name)


# Add costa rica survey locations
cr_locs<- data.frame(location_code=c("AIRS02", "CERR02","LOMAS01"), 	
           latitude=c(8.402595,	8.416142,8.758321)	,
           longitude=c( -83.35852,	-83.31793,	-83.29787) )




```

*Last data request: `r now(tzone = "America/Costa_Rica")`*

The project currently contains `r length(unique(dat$tag_id))` active tag deployments (defined as being active within the last 14 days). 

```{r  c02, include=F}

# Add a country column
dat$country <- dat$location_lat<0
dat$country[dat$country==T] <- "peru"
dat$country[dat$country==F] <- "costa_rica"
#table(dat$country)

# Costa rica
# Convert to shapefiles
dat <- dat[order(dat$animalName),]

lfc <- do.call(st_sfc,
              lapply(split(dat, dat$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(name=levels(factor(dat[,"name"])), geom=lfc))

#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

sp_dat <- dat[,c("name",    "country", "taxon_canonical_name" )]
sp_dat <- sp_dat[duplicated(sp_dat)==F,]

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

```

**Time since last check-in**

```{r  c03, echo=F, include=F}
# Last location and time since present
dat$diff_time <- round(as.numeric(difftime(t, dat$timestamp, units="days")),1)

last_obs <- dat %>% group_by(name) %>% dplyr::summarize(days_since_fix=min(diff_time))

last_sum  <- dat %>% 
  group_by(name) %>%
  slice(which.max(timestamp))


tmp <- last_sum[, c("name","taxon_canonical_name","country", "timestamp", "diff_time")]
colnames(tmp)[colnames(tmp)=="diff_time"] <- "days_since_checkin"
colnames(tmp)[colnames(tmp)=="timestamp"] <- "last_timestamp"
check_in_summary <- tmp[order(tmp$country, tmp$days_since_checkin),]


```


```{r  c04, echo=F, message=F, warning=F}
tmp_col <- check_in_summary$days_since_checkin
tmp_col[tmp_col<12]<- 12

### Total locations Mean eobs battery power, eobs accuracy
tmp_sum <- dat %>% group_by(name) %>% dplyr::summarise(total_obs=n(), start_date=min(timestamp, na.rm=T), end_date=max(timestamp, na.rm=T))
tmp_sum$days_of_data <- round(difftime(tmp_sum$end_date, tmp_sum$start_date),0)
#colnames(dat)
tmp_sum$start_date <- substr(tmp_sum$start_date,1,10)

check_in_summary <- left_join(check_in_summary, tmp_sum)
check_in_summary$last_timestamp <- NULL

check_in_summary$locs_per_day <- round(check_in_summary$total_obs/as.numeric(check_in_summary$days_of_data),0)
check_in_summary$end_date <- substr(check_in_summary$end_date,1,10)


check_in_summary %>%
  kbl() %>%
  kable_styling()  %>%
    column_spec(4, color = "white",
              background = spec_color(tmp_col, begin=0,end = 0.7, direction=-1,
                                      option="D", scale_from = c(12,120)))%>%
  kableExtra::scroll_box(width = "100%")
```

**Tagging summary**

We have tagged `r nrow(check_in_summary)` birds to date, the breakdown by country is:

```{r, echo=F}

tmp <- as.data.frame.matrix(table(check_in_summary$taxon_canonical_name, check_in_summary$country))
tmp$taxon_canonical_name <- row.names(tmp)
fig <- plot_ly(tmp, x = ~taxon_canonical_name, y = ~costa_rica, type = 'bar', name = 'Costa Rica')
fig <- fig %>% add_trace(y = ~peru, name = 'Peru')
fig <- fig %>% layout(yaxis = list(title = 'Count'), barmode = 'stack')

fig
```

**Maps**

All of our tracking data

*Costa Rica*

```{r, echo=F}
tmp_cr <- dat[dat$country=="costa_rica",]
tmp_cr_shp <- dat_shp[dat_shp$country=="costa_rica",]


# First lets choose a category to colour
tmp_cr[,"name"] <- factor(tmp_cr[,"name"])
tmp_cr_shp$name <- factor(tmp_cr_shp$name)

col.cat <- turbo(length(levels(tmp_cr[,"name"])))
# Add it to the dataframe
tmp_cr$colours <- col.cat[tmp_cr[,"name"]]
tmp_cr_shp$colours <- col.cat[tmp_cr_shp$name]

```

We currently have `r length(unique(tmp_cr$name))` devices transmitting data in Costa Rica:

```{r, echo=F}

# New map
ids <- tmp_cr_shp$name
names <- sub('\\_.*', '', tmp_cr_shp$name)
i <- 5
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%  
    addProviderTiles(providers$Stamen.TonerLite, group="Simple")   

  for(i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_shp[i,], color = tmp_cr_shp$colours[i], group = ids[i], weight=1,opacity=0.5, popup = ids[i])
        
        
    }

  m <- m %>%
      # Add survey location
      addMarkers(lng=cr_locs$longitude,
                         lat=cr_locs$latitude, 
                         popup=cr_locs$location_code) %>% 
      #addLegend(position= "topright", colors=tmp_cr_shp$colours, 
       #         labels=names ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple", "OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```


*Peru*

```{r, echo=F}
tmp_peru <- dat[dat$country=="peru",]
tmp_peru_shp <- dat_shp[dat_shp$country=="peru",]


# First lets choose a category to colour
tmp_peru[,"name"] <- factor(tmp_peru[,"name"])
tmp_peru_shp$name <- factor(tmp_peru_shp$name)

col.cat <- turbo(length(levels(tmp_peru[,"name"])))
# Add it to the dataframe
tmp_peru$colours <- col.cat[tmp_peru[,"name"]]
tmp_peru_shp$colours <- col.cat[tmp_peru_shp$name]

```

We currently have `r length(unique(tmp_peru$name))` devices transmitting data in Peru:


```{r, echo=F}
# New map
ids <- tmp_peru_shp$name
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%  
    addProviderTiles(providers$Stamen.TonerLite, group="Simple")


  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_shp[i,], color = tmp_peru_shp$colours[i], group = ids[i], weight=1,opacity=0.5)  
    }
    
  m <- m %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple","OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```

### Movement summaries

We first regularize all of the data to one our intervals, then calculate distance moved

#### King vultures

Average daily movement distance (1 hour intervals): 

```{r}
# Test to see if I can regularise data
ids <- tmp_cr_shp$name

kings <- tmp_cr_shp$name[tmp_cr_shp$taxon_canonical_name=="Sarcoramphus papa"]

turkey <- tmp_cr_shp$name[tmp_cr_shp$taxon_canonical_name=="Cathartes aura"]

#######
mov_regular <- list()
for(i in 1:length(ids))
{
  tmp <- interpolateTime(mov_dat[[as.character(ids[i])]], time=as.difftime(60,units="mins"), spaceMethod='greatcircle')
  tmp$distance_km <- c(NA, distance(tmp)/1000)
  mov_regular[[i]] <- as.data.frame(tmp)
  print(i)
}

mov_regular <- bind_rows(mov_regular)

# plot(test_df$location_long.1, test_df$location_lat.1, asp=1)
# plot(test_df$location_long, test_df$location_lat, asp=1)

mov_regular$date <- ymd(substr(mov_regular$timestamps,1,10))

tmp_res <- mov_regular %>% group_by(local_identifier, date) %>% summarize(obs=n(), daily_km=sum(distance_km))

tmp_res <- tmp_res[tmp_res$obs>23,]


ymax <- max(tmp_res$daily_km, na.rm=T)



p0 <- ggplot(tmp_res[tmp_res$local_identifier %in% kings,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax)) + ggtitle("All data")

ggplotly(p0)


p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% kings,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~local_identifier, ncol = 5) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)

```

#### Turkey Vultures

```{r}

ymax <- max(tmp_res$daily_km[tmp_res$local_identifier %in% turkey], na.rm=T)


p0 <- ggplot(tmp_res[tmp_res$local_identifier %in% turkey,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax)) + ggtitle("All data")

ggplotly(p0)


p1 <- ggplot(tmp_res[tmp_res$local_identifier %in% turkey,], aes(x = date, y = daily_km)) +
    geom_point() +
    stat_smooth(method = "loess") +
     facet_wrap(~local_identifier, ncol = 5) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, ymax))

ggplotly(p1)

```




# Costa Rica  {.tabset}

### Point density

Below we show the logged point density accross our area of interest. Note, the extreme number of values on the Peninsula means we can't do a color ramp on the observation scale. 

```{r}
# Density raster
dat_sf_cr <- st_as_sf(tmp_cr, coords=c("location_long", "location_lat"), crs=4326)

# Write_for my files
#st_write(tmp_cr_shp, "C:/Users/cwbei/Dropbox/Osa Conservation/Data analysis/current_vulture_data/vulture_tracks.shp", append=F)



<<<<<<< HEAD
#bg <- ne_countries(scale = "large", country=c("Costa Rica", "Panama"), #returnclass = "sf")
#bg <- st_make_valid(bg)
#st_write(bg, "landmass.shp", append=F)
bg <- st_read("landmass.shp")

# make a fishnet grid over the countries
grd <- st_make_grid(dat_sf_cr, n = 200)
# visualize the grid
#plot(grd)

=======
bg <- ne_countries(scale = "large", country=c("Costa Rica", "Panama"), returnclass = "sf")
# make a fishnet grid over the countries
grd <- st_make_grid(dat_sf_cr, n = 200)
# visualize the grid
plot(grd)

>>>>>>> 3a5461bed42b6377d4c8afa6f7e2ccb335db3b0d
index <- which(lengths(st_intersects(grd, dat_sf_cr)) > 0)
# subset the grid to make a fishnet
fishnet <- grd[index]

# visualize the fishnet
#plot(fishnet)
#plot(bg, add=T, col="#f2f2f2", border=F)
#plot(fishnet,add=T)



test <- fishnet %>%   
  st_as_sf() %>% # cast to sf
  mutate(grid_id = row_number()) %>% # create unique ID
  st_join(dat_sf_cr) %>% # join the species dataset
  group_by(grid_id) %>% # group by the grid id
  count() 

tmp <- st_as_sf(test)

ii <- cut(tmp$log.n, breaks = seq(min(tmp$log.n), max(tmp$log.n), len = 100), 
          include.lowest = TRUE)
## Use bin indices, ii, to select color from vector of n-1 equally spaced colors
colors <- inferno(99)[ii]

col_dat <- data.frame(values=seq(min(tmp$log.n), max(tmp$log.n), len = 100), colours=inferno(100))
col_dat$values_obs <- round(exp(col_dat$values),0)


m <- leaflet(tmp) %>%
  # Add a satellite image layer
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%  
    addProviderTiles(providers$Stamen.TonerLite, group="Simple")%>%  
  addPolygons(stroke=F, color=colors, fillOpacity=0.7, label=tmp$n, group = "Raster")
#?addPolygons  
m <- m %>%
      addLegend(position= "topright", colors=col_dat$colours[c(1,10,20,30,40,50,60,70,80,90,100)], 
                labels=c(1,col_dat$values_obs[c(10,20,30,40,50,60,70,80,90,100)]) ,opacity = 0.7, title = "point density") %>%    
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple","OS", "Satellite"),
        overlayGroups = c("Raster"),
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```

### Feeding clusters

The following map shows all of the vulture clusters.

We define a cluster where a bird stays for >80 minutes within 100m of its starting location. Provided it arrives after 08:00 am or before 16:00.  

### Costa Rica
```{r, eval=T, echo=F, message=F, warning=F}
# Code derived from
# https://github.com/movestore/Daily-Rest-Sites
#library('maptools')
#library('ggmap')


# Subset to costa rica and vultures
sub_dat <- mov_dat[mov_dat$location_lat>0 ,]

sub_dat$speed <- unlist(lapply(move::speed(sub_dat),c, NA ))
sub_dat_df <- as.data.frame(sub_dat)
sub_dat_df <- left_join(sub_dat_df, animals[, c("tag_id", "name", "taxon_canonical_name")])


sub_dat_df <- sub_dat_df[order(sub_dat_df$name),]

# Add in icon column
sub_dat_df$icon <- sub(".*? ", "", sub_dat_df$taxon_canonical_name)




lfc <- do.call(st_sfc,
              lapply(split(sub_dat_df, sub_dat_df$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(name=levels(factor(sub_dat_df[,"name"])), geom=lfc))

#plot(st_geometry(dat_shp))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

# Bring in the colours from earlier
cr_cols <- tmp_cr[, c("name", "colours")]
cr_cols <- cr_cols[duplicated(cr_cols)==F,]
dat_shp <- left_join(dat_shp, cr_cols)
# Make shapefile of the tracks to add later

#plot(sub_dat_df$ground_speed, sub_dat_df$speed)
#plot(sub_dat_df$ground_speed, sub_dat_df$height_above_ellipsoid)

#plot(sub_dat, col=as.numeric(sub_dat$ground_speed<1)+1)
#plot(sub_dat[sub_dat$ground_speed<1,], add=T)



# Specifiy the settings

data=sub_dat
window="sunupdown"
upX=0
downX=0
speedvar="speed"
maxspeed=0.2

duration=1.2
radius=100


#rFunction <- function(data, window="all", upX=0, downX=0, speedvar="speed", maxspeed=NULL, duration=NULL, radius=NULL)
#{
  Sys.setenv(tz="America/Costa_Rica")
  
  names(data) <- make.names(names(data),allow_=FALSE)
  
  # add species info
  data.df <- as.data.frame(data)
  names(data.df) <- make.names(names(data.df),allow_=FALSE)
  #if (any(names(data.df)=="individual.taxon.canonical.name")) data@data$species <- data.df$individual.taxon.canonical.name
  data@data$species <- data.df$taxon.canonical.name
  
  speedx <- function(x) #input move object
  {
    N <- length(x)
    distVincentyEllipsoid(coordinates(x))/as.numeric(difftime(timestamps(x)[-1],timestamps(x)[-N],units="secs"))
  }

  n.all <- length(timestamps(data))
  data <- data[!duplicated(paste0(round_date(timestamps(data), "5 mins"), trackId(data))),]
  
    data.split <- move::split(data)
    data.ground <- foreach(datai = data.split) %do% {
        if (speedvar=="speed") 
        {
          if (length(datai)>1) #cannot calculated between-loc speed if only one location, therefore keep
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
 #           logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        } else if (speedvar %in% names(datai)) 
        {
          res <- datai[datai@data[,speedvar]<maxspeed | is.na(datai@data[,speedvar]),] # this allows also NA speed to be selected
#          logger.info("Your speed variable contains NA, these are kept in the data set of rest positions.")
        } else 
        {
#          logger.info("You have not selected a viable speed variable. Therefore the fallback between location speed is calculated.")
          if (length(datai)>1)
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
#            logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        }
        res
    }
    names(data.ground) <- names(data.split)
    data.ground <- moveStack(data.ground[unlist(lapply(data.ground, length) > 0)])
    
    # select night or day positions (use data.ground, call it "night")
    data.ground.split <- move::split(data.ground)
    data.night <- foreach(data.groundi = data.ground.split) %do% {
      #print(namesIndiv(data.groundi))
      sunupx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunrise", POSIXct.out=TRUE))$time + upX*60
      sundownx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunset", POSIXct.out=TRUE))$time + downX*60
      data.groundi@data <- cbind(data.groundi@data,sunupx,sundownx)

      ix <- which(is.na(sunupx) | is.na(sundownx))
      
      ix_ArcSum <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_ArcWin <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      ix_AntWin <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_AntSum <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      
      if (window=="all")
      {
        data.nighti <- data.groundi
        year <- as.POSIXlt(timestamps(data.nighti))$year+1900
        yday <- as.POSIXlt(timestamps(data.nighti))$yday
        data.nighti@data <- cbind(data.nighti@data,year,yday)
      } else
      {
        if (window=="sundownup") #night roosts
        {
          if (length(ix_ArcSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcSum,]
          }
          if (length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntSum,]
          }
          
          if (length(ix_ArcWin)>0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) and", length(ix_AntWin), " southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin,ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin,ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin,ix_AntWin)),]
          } else if (length(ix_ArcWin)>0 & length(ix_AntWin)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin)),]
          } else if (length(ix_ArcWin)==0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntWin)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)<=data.groundi$sunupx | timestamps(data.groundi)>=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          ynight <- yday
          
          ixx <- which(is.na(data.nighti$sundownx))
          if (length(ixx)>0)
          {
            ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]] <- ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]]+1
            
            # for Arctic/Antarctic nights the night goes from midday to midday, which depends on the location..
            midday_ixx <- solarnoon(coordinates(data.nighti[ixx]),timestamps(data.nighti[ixx]),POSIXct.out=TRUE)$time
            ynight[timestamps(data.nighti[ixx])>midday_ixx] <- ynight[timestamps(data.nighti[ixx])>midday_ixx]+1
          } else ynight[timestamps(data.nighti)>data.nighti$sundownx] <- ynight[timestamps(data.nighti)>data.nighti$sundownx]+1
          
          # adapt for New Year's Eve
          year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx]+1
          ynight[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- 0
          
          data.nighti@data <- cbind(data.nighti@data,year,yday,ynight)
        }
        
        if (window=="sunupdown") # day rests
        {
          if (length(ix_ArcWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcWin,]
          }
          if (length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntWin,]
          }
          
          if (length(ix_ArcSum)>0 & length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) and", length(ix_AntSum), " southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum,ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum,ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum,ix_AntSum)),]
          } else if (length(ix_ArcSum)>0 & length(ix_AntSum)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum)),]
          } else if (length(ix_ArcSum)==0 & length(ix_AntSum)>0)
          {
#            logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntSum)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)>=data.groundi$sunupx & timestamps(data.groundi)<=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          data.nighti@data <- cbind(data.nighti@data,year,yday)
        }
      }
      return(data.nighti)   
    }
    if (is(data.night,'Move')) data.night <- moveStack(data.night,forceTz="America/Costa_Rica") #force to movestack
    names (data.night) <- names(data.ground.split)
    data.night.nozero <- data.night[unlist(lapply(data.night, length) > 0)]
    
    {
      data.night <- moveStack(data.night.nozero)
      data.night.df <- as.data.frame(data.night)
      nacolx <- which(apply(data.night.df,2,function (x) all(is.na(x))))
      if (length(nacolx)>0) data.night.df.nna <- data.night.df[,-nacolx] else data.night.df.nna <- data.night.df #remove columns with all NA
      
      #write.csv(data.night.df.nna,file = paste0("data_rest_selectedTime.csv"),row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      #write.csv(data.night.df.nna,file = "data_rest_selectedTime.csv",row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      
      # save all rest positions if is rest by given definition (radius, duration), goes backwards for last night/day rest
      data.night.split <- move::split(data.night)
      
      if (window=="all")
      {
        prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      } else
      {
        if (window=="sundownup") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"ynight"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
        if (window=="sunupdown") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      }
      
      data.rest <- foreach(data.nighti = data.night.split) %do% {
#        logger.info(paste("Extracting rest sites of",namesIndiv(data.nighti)))
        data.resti.df <- data.frame(as.data.frame(moveStack(data.nighti)),coordinates(data.nighti))[0,] #empty df to fill, moveStack to keep trackId
        Nresti <- dim(data.resti.df)[2]
        names(data.resti.df)[(Nresti-1):Nresti] <- c("location.long","location.lat")
        
        year <- unique(data.nighti@data$year)
        for (k in seq(along=year))
        {
          
          data.nightik <- data.nighti[data.nighti@data$year==year[k],]
          
          if (window=="all")
          {
            night <- unique(data.nightik@data$yday)
          } else
          {
            if (window=="sundownup") night <- unique(data.nightik@data$ynight)
            if (window=="sunupdown") night <- unique(data.nightik@data$yday)
          }
          
          for (j in seq(along=night))
          {
            
            if (window=="all")
            {
              data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            } else
            {
              if (window=="sundownup") data.nightikj <- data.nightik[data.nightik@data$ynight==night[j],]
              if (window=="sunupdown") data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            }
            
            last <- Nikj <- length(data.nightikj)
            while (last>1) # as long as first night/day position is not the last
            {
              data.nightikj <- data.nightikj[1:last,]
              backdt <- as.numeric(difftime(timestamps(data.nightikj)[last],timestamps(data.nightikj)[-c(last:Nikj)],units="hours"))
              if (length(backdt)>=1) #changed this to allow for further away position (if in radius assume not moved), allows for worse resolution data
              {
                # note that here not yet checked that duration in site complete, later
                if (any(backdt<=duration)) 
                {
                  data.sel <- data.nightikj[c(which(backdt<=duration),last),] 
                  #data.sel$timestamp
                  data.rem <- data.nightikj[-c(which(backdt<=duration),last),]
                  #data.rem$timestamp
                  #plot(data.nightikj$location.long, data.nightikj$location.lat)
                  #points(data.sel$location.long, data.sel$location.lat, col="green")
                  #points(data.rem$location.long, data.rem$location.lat, col="red")
                  
                } else
                {
                  data.sel <- data.nightikj[(last-1):last,]
                  data.rem <- data.nightikj[-c((last-1):last),]
                  
                }
                m <- colMeans(coordinates(data.sel))
                dp0 <- distVincentyEllipsoid(m,coordinates(data.sel))
                p0 <- coordinates(data.sel)[min(which(dp0==max(dp0))),]
                dp1 <- distVincentyEllipsoid(p0,coordinates(data.sel))
                p1 <- coordinates(data.sel)[min(which(dp1==max(dp1))),]
                maxdist <- distVincentyEllipsoid(p0,p1)
                
                if (maxdist<radius)
                {
                  ## check if already longer at this rest site
                  mid <- midPoint(p0,p1)
                  #points(mid[1], mid[2], col="blue")
                  data.bef <- data.rem
                  if (length(data.bef)>=1)
                  {
                    dist.bef <- distVincentyEllipsoid(mid,coordinates(data.bef))
                    if (any(dist.bef>radius))
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      
                    } else 
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration),which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration),which(backdt<=duration),last),]
                    }
                  } else 
                  {
                    data.selx <- data.sel
                    data.remx <- data.rem
                  }
                  
                  data.selx.df <- data.frame(as.data.frame(moveStack(data.selx)),coordinates(data.selx))
                  # Check what is in there
                  #points(data.selx.df$location.long, data.selx.df$location.lat, col="yellow", pch=19)
                  # looks good
                  
                  Nselx <- dim(data.selx.df)[2]
                  names(data.selx.df)[(Nselx-1):Nselx] <- c("location.long","location.lat")
                  
                  time0 <- min(timestamps(data.selx))
                  timeE <- max(timestamps(data.selx))
                  durx <- as.numeric(difftime(timeE,time0,unit="hour"))
                  radx <- max(distVincentyEllipsoid(mid,coordinates(data.selx)))
                  
                  if (durx>=duration & radx<=radius) #added this condition to only save rest sites of given duration (if this condition is left out also rest site with shorter duration are given back)
                  {
                    data.resti.df <- rbind(data.resti.df,data.selx.df)
                    #points(data.resti.df$location.long, data.resti.df$location.lat, pch="x")
                    
                    
                    if (window=="all")
                    {
                      prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species,"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    } else
                    {
                      if (window=="sundownup") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"ynight"=data.selx.df$ynight[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                      if (window=="sunupdown") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    }
                  }
                  
                  
                  data.nightikj <- data.remx
                  #points(data.nightikj$location.long, data.nightikj$location.lat, pch="w")
                  
                  last <- Nikj <- length(data.nightikj) #this can be zero, will be stop indication in while() condition
                  
                } else last <- last-1 #shift one time step
              } else last <- last-1 # shift one time step also if not enough data in previous Xh time frame
            } #while
          } #for j
        } #for k
        if (dim(data.resti.df)[1]>0) 
        {
          o <- order(data.resti.df$timestamp)
          data.resti <- move(x=data.resti.df$location.long[o],y=data.resti.df$location.lat[o],time=as.POSIXct(data.resti.df$timestamp[o]),data=data.resti.df[o,],sensor=data.resti.df$sensor[o],animal=data.resti.df$trackId[o])
          
        } else data.resti <- NULL
      }
      names(data.rest) <- names(data.night.split)
      data.rest.nozero <- data.rest[unlist(lapply(data.rest, length) > 0)] #remove IDs with no data
      
      if (length(data.rest.nozero)==0) 
      {
#        logger.info("Your output file contains no positions. No csv overview and plot saved. Return NULL.")
        result <- NULL
      } else 
      {
        result <- moveStack(data.rest.nozero)
        #write.csv(prop.rest.df,file = paste0("rest_overview.csv"),row.names=FALSE) #csv artefakt
        #write.csv(prop.rest.df,file = "rest_overview.csv",row.names=FALSE)
        
        
                #map <- get_map(bbox(extent(data)),source="stamen",force=TRUE)
        
        #data.df <- data.frame(coordinates(data),as.data.frame(moveStack(data)))
        #names(data.df)[1:2] <- c("location.long0","location.lat0")
        
        #out <- ggmap(map) +
        #  geom_path(data=data.df,aes(x=location.long0,y=location.lat0,group=trackId),colour="blue") +
        #  geom_point(data=prop.rest.df,aes(x=rest.mean.long,y=rest.mean.lat),colour="red",size=3)

                #ggsave(out, file = paste0("rest_sites_onTracks.pdf"))
        
        # note that all timestamps are UTC!
      }
    }
  #}
  #return(result)
#test <- as.data.frame(result)
#plot(result)
#str(test)

#
clus_res <- prop.rest.df


# Convert the timestamps
clus_res$timestamp.first <- with_tz(ymd_hms(clus_res$timestamp.first), tz="America/Costa_Rica")
clus_res$timestamp.last <- with_tz(ymd_hms(clus_res$timestamp.last), tz="America/Costa_Rica")
clus_res$code <- paste0(toupper(substr(clus_res$local.identifier,1,3)),"_", substr(clus_res$timestamp.first,12,13),substr(clus_res$timestamp.first,3,4),substr(clus_res$timestamp.first,6,7),substr(clus_res$timestamp.first,9,10))  

# # Leaflet the data and add the output
# cols <- c("red", "blue")
# 
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat$ground_speed<1)+1]) 
# 
#  m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat_df$speed<0.1)+1]) 
# 
# m 
#  
#    
#   m <- m %>%
#         addCircleMarkers(lng=tmp$rest.mean.long,
#                          lat=tmp$rest.mean.lat, 
#                          popup=paste("duration =",tmp$rest.duration, "npos =",tmp$rest.nposi),
#                          fillOpacity = 0.3, opacity = 0.7, radius=4, color="orange") 
# 
# m  
 
# Try and define roost sites

clus_res$hour<- as.numeric(substr(clus_res$timestamp.first,12,13))


clus_res$type <- NA
clus_res$type[clus_res$hour<8] <- "night_roost"
clus_res$type[clus_res$hour>15] <- "night_roost"

clus_res$type[as.numeric(substr(clus_res$timestamp.first,12,13))>7 &  as.numeric(substr(clus_res$timestamp.first,12,13))< 16] <- "potential_feeding"

boxplot(clus_res$rest.duration~clus_res$type)


hist(clus_res$rest.duration[clus_res$type=="potential_feeding"])

summary(clus_res$rest.duration[clus_res$type=="potential_feeding"])

clus_res$type_col <- NA
clus_res$type_col[clus_res$type=="potential_feeding"] <- "yellow"
clus_res$type_col[clus_res$type!="potential_feeding"] <- "red"



m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addCircleMarkers(lng=clus_res$rest.mean.long,
                         lat=clus_res$rest.mean.lat, 
                         popup=paste("name"=clus_res$local.identifier, 
                                     "<br>duration =",round(clus_res$rest.duration,1), "h", 
                                     "<br>time =",substr(clus_res$timestamp.first, 12,16), "-", substr(clus_res$timestamp.last, 12,16),
                                     "<br>npos =",clus_res$rest.nposi, " Radius =" ,round(clus_res$rest.radius,1),"m",
                                     "<br>lon =" ,round(clus_res$rest.mean.lon,6)  , "lat =", round(clus_res$rest.mean.lat,6),
                                     "<br>code =", clus_res$code) 
                                     ,
                          fillOpacity = 0.8, opacity = 0.7, radius=2, stroke=F, fillColor = clus_res$type_col)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
      )  %>% 
    addLegend(position="topright", labels=c("potential feeding", "likely roost"), colors=c("yellow","red"), title="Cluster age")


  m

 

  # I could link last nighttime point with mporning clusters
  
  
```


### Habitat use

```{r}
# Convert the point shapefile into vect format and extract the habitat type for each bird

cr_terra_points <- vect(dat_sf_cr) 
<<<<<<< HEAD

tmp <- extract(habitat, cr_terra_points)
=======
>>>>>>> 3a5461bed42b6377d4c8afa6f7e2ccb335db3b0d

cr_terra_points$habitat <- extract(habitat, cr_terra_points)

<<<<<<< HEAD
dat_sf_cr$NB_LAB <- tmp$`ESACCI-global-10m_merged`
dat_sf_cr <- left_join(dat_sf_cr, habitat_key)

cr_hab_dat <- as.data.frame(dat_sf_cr)

ind_res <- cr_hab_dat %>% group_by(local_identifier, LCCOwnLabel) %>% 
summarise(count=n())

ind_res <- as.data.frame(ind_res)

ind_res$LCCOwnLabel

ind_res_wide <- reshape(ind_res, idvar="local_identifier", timevar="LCCOwnLabel", direction="wide")

# MAkes NA's 0
ind_res_wide[is.na(ind_res_wide)]<- 0
# up[date column names
colnames(ind_res_wide)[2:ncol(ind_res_wide)] <- c("sparse_veg", "urban", "cropland", "grassland", "wetland", "mangrove","water", "trees", "shrubs" )

# Count total opbs
tmp <- rowSums(ind_res_wide[,2:ncol(ind_res_wide)])
ind_res_prop <- ind_res_wide
ind_res_prop[,2:ncol(ind_res_wide)] <- round(ind_res_wide[,2:ncol(ind_res_wide)]/tmp,4)

#


=======
as.data.frame(cr_terra_points)
>>>>>>> 3a5461bed42b6377d4c8afa6f7e2ccb335db3b0d


```

