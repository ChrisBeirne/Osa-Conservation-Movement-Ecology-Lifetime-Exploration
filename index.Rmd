---
title: "Osa Conservation: Movement report"
author:
  - Chris Beirne
site: bookdown::test-bookdown
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
editor_options: 
  chunk_output_type: console
---

# Device Status

This document summarizes the movement locations for all active devices within Osa Conservation's movement ecology project. 

```{r c01, echo=F, message=F, include=F}
knitr::opts_chunk$set(echo = FALSE, message=F, warning=F)

library(rgdal) 
library(move)
library(dplyr)
library(leaflet)
library(units)
library(sf)
library(viridis)
library(kableExtra)
library(lubridate)
library(plotly)
## Load packages for google drive ----
library(googledrive)
library(purrr)
library(readxl)
library(geosphere)
library(foreach)
library(maptools)
library(leaflet.opacity)
library(leaflet.extras)

options(googledrive_quiet = TRUE)

# For when the trapping effort file is sorted
# googledrive::drive_auth(path = Sys.getenv("GOOGLE_AUTHENTICATION_CREDENTIALS"))
# 
# ## Find Google Drive folder 'Centre Circle Data & Info'
# data_folder <- drive_ls(path = "08 Databases + Analysis")
# data_path <- "data" 
# dir.create(data_path) 
# drive_download(as_id("14hLi94W4WbDn6jdXahJMnxllOgLpZh-PpIBOWqt9jlc"),
#                path="data/2_vulture_trap_deployments.xlsx")
#capture_dat <- read_excel("data/2_vulture_trap_deployments.xlsx")



# Import passcodes
MOVE_PASS <- Sys.getenv("MOVEBANK_PASSWORD")
MOVE_USE  <- Sys.getenv("MOVEBANK_USERNAME")

loginStored <- movebankLogin(username=MOVE_USE, 
                             password=MOVE_PASS)

# Get animals
# Vultures
animals <-getMovebankAnimals(study=1573471517,login=loginStored)
# Ocelot
tmp <-getMovebankAnimals(study=2526574641,login=loginStored)
# Tapir
tmp2 <- getMovebankAnimals(study=1954804459,login=loginStored)
animals <- rbind(animals, tmp,tmp2)

# For some reason they are duplicated
animals[duplicated(animals)==F,]
# They vary by the field "sensor_type_id"
animals <- animals[animals$sensor_type_id==653 & is.na(animals$sensor_type_id)==F,]

# Clean up the name
animals$animalName <- paste0(sub('\\_.*', '', animals$animalName), "_", sub('\\ .*', '', animals$taxon_canonical_name))
animals$name <- sub('\\_.*', '', animals$animalName)

# Sort date objects
animals$timestamp_start <- ymd_hms(animals$timestamp_start)
animals$timestamp_end <- ymd_hms(animals$timestamp_end)

# Get last 2 weeks
t <- now("America/Costa_Rica")
start_t <- t-as.difftime(14,units='days')
start_tapir <- t-as.difftime(48,units='days')

# Vultures
mov_dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE,
                       timestamp_start=start_t)
#OCelot
tmp <- getMovebankData(study=2526574641, login=loginStored,  removeDuplicatedTimestamps=TRUE,
                       timestamp_start=start_t)

#Tapir
tmp2 <- getMovebankData(study=1954804459, login=loginStored,  removeDuplicatedTimestamps=TRUE,
                       timestamp_start=start_tapir)

# Remove the obvious outlier
tmp2 <- tmp2[tmp2$location_lat>8,]

mov_dat <- moveStack(mov_dat, tmp, tmp2)



#Add the names
mov_dat$name <- trackId(mov_dat)


# Convert timezone
mov_dat$timestamp <- with_tz(timestamps(mov_dat), tz="America/Costa_Rica")

# all data
#dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)

# Convery move stack to dataframe
dat <- as.data.frame(mov_dat)

# Convert dat to costa rica time
dat$timestamp <- with_tz(dat$timestamp, tzone = "America/Costa_Rica")

# Add the location data
dat <- left_join(dat, animals[, c("tag_id", "animalName")])
# Sort the names out

dat$animalName <- sub('\\_.*', '', dat$animalName)
# Add in the taxonomic group
dat$animalName <- paste0(dat$animalName, "_", sub('\\ .*', '', dat$taxon_canonical_name))

# # Setup the leaflet icon
# leafIcons <- icons(
#   iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small1.png",
#   iconWidth = 38, iconHeight = 40,
#   iconAnchorX = 22, iconAnchorY = 39,
#   shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
#   shadowWidth = 38, shadowHeight = 30,
#   shadowAnchorX = 4, shadowAnchorY = 39
# )
# #?iconList()

papa <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/king_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

aura <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/turk_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

mela <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/yhv_small.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39,
  shadowUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/vul_small_shadow.png",
  shadowWidth = 38, shadowHeight = 30,
  shadowAnchorX = 4, shadowAnchorY = 39)

pardalis <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/ocelot.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39)

bairdii <- makeIcon(
  iconUrl = "https://raw.githubusercontent.com/ChrisBeirne/Osa-Conservation-Movement-Ecology-Daily-Report/main/icons/tapir.png",
  iconWidth = 38, iconHeight = 40,
  iconAnchorX = 22, iconAnchorY = 39)

iconSet <- iconList(aura= aura,
                    papa =papa,
                    melambrotus = mela,
                    pardalis = pardalis,
                    bairdii = bairdii)

dat$icon <- sub(".*? ", "", dat$taxon_canonical_name)


# Add costa rica survey locations
cr_locs<- data.frame(location_code=c("AIRS02", "CERR02","LOMAS01"), 	
           latitude=c(8.402595,	8.416142,8.758321)	,
           longitude=c( -83.35852,	-83.31793,	-83.29787) )





```

*Last data request: `r now(tzone = "America/Costa_Rica")`*

The project currently contains `r length(unique(dat$tag_id))` active tag deployments (defined as being active within the last 14 days). 

```{r  c02, include=F}

# Add a country column
dat$country <- dat$location_lat<0
dat$country[dat$country==T] <- "peru"
dat$country[dat$country==F] <- "costa_rica"
#table(dat$country)

# Costa rica
# Convert to shapefiles
dat <- dat[order(dat$animalName),]

lfc <- do.call(st_sfc,
              lapply(split(dat, dat$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(name=levels(factor(dat[,"name"])), geom=lfc))

#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

sp_dat <- dat[,c("name",    "country", "taxon_canonical_name" )]
sp_dat <- sp_dat[duplicated(sp_dat)==F,]

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

```

**Time since last check-in**

```{r  c03, echo=F, include=F}
# Last location and time since present
dat$diff_time <- round(as.numeric(difftime(t, dat$timestamp, units="hours")),1)

last_obs <- dat %>% group_by(name) %>% dplyr::summarize(hours_since_fix=min(diff_time))

last_sum  <- dat %>% 
  group_by(name) %>%
  slice(which.max(timestamp))


tmp <- last_sum[, c("name","taxon_canonical_name","country", "timestamp", "diff_time")]
colnames(tmp)[colnames(tmp)=="diff_time"] <- "time_since_checkin_h"
colnames(tmp)[colnames(tmp)=="timestamp"] <- "last_timestamp"
check_in_summary <- tmp[order(tmp$country, tmp$time_since_checkin_h),]


```


```{r  c04, echo=F, message=F, warning=F}
tmp_col <- check_in_summary$time_since_checkin_h
tmp_col[tmp_col<12]<- 12

check_in_summary[,c(1,2,3,5)] %>%
  kbl() %>%
  kable_styling()  %>%
    column_spec(4, color = "white",
              background = spec_color(tmp_col, begin=0,end = 0.7, direction=-1,
                                      option="D", scale_from = c(12,120)))%>%
  kableExtra::scroll_box(width = "100%")


### Add additional data shown later
check_in_summary$duration <- difftime(check_in_summary$last_timestamp, start_t, "days")

### Total locations Mean eobs battery power, eobs accuracy
tmp_sum <- dat %>% group_by(name) %>% dplyr::summarise(total_obs=n(), mean_batt=mean(eobs_battery_voltage, na.rm=T), loc_accuracy=mean(eobs_horizontal_accuracy_estimate, na.rm=T))
#colnames(dat)

check_in_summary <- left_join(check_in_summary, tmp_sum)
check_in_summary$locs_per_day <- check_in_summary$total_obs/as.numeric(check_in_summary$duration)

```

**Animals not seen for >14 days**

```{r  c05, echo=F}
tmp2 <- animals[!(animals$name %in% tmp$name),]
tmp2$timestamp_end <- with_tz(substr(tmp2$timestamp_end,1,19), tzone = "America/Costa_Rica")
#str(tmp2)
tmp2$days_since_check_in<- round(as.numeric(difftime(t, tmp2$timestamp_end, units="days")),1)
tmp2 <- tmp2[order(tmp2$days_since_check_in),]
#row.names(tmp2) <- 1:nrow(tmp2)



tmp2[, c("name", "timestamp_end", "days_since_check_in")] %>%
  kbl() %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%")

```

**Tagging summary**

The proportion of active tags by country:

```{r, echo=F}
library(plotly)

library(dplyr)

fig <- plot_ly()
# All vultures - Countries
fig %>% add_pie(data = dplyr::count(check_in_summary, country), labels = ~country, values = ~n,

          name = "Country")
```

And by species:

```{r, echo=F}
fig <- plot_ly()
# All vultures - Species
fig %>% add_pie(data = dplyr::count(check_in_summary, taxon_canonical_name), labels = ~taxon_canonical_name, values = ~n,

          name = "Species")

```


**Maps**

Last 14 days:

*Costa Rica*

```{r, echo=F}
tmp_cr <- dat[dat$country=="costa_rica",]
tmp_cr_shp <- dat_shp[dat_shp$country=="costa_rica",]


# First lets choose a category to colour
tmp_cr[,"name"] <- factor(tmp_cr[,"name"])
tmp_cr_shp$name <- factor(tmp_cr_shp$name)

col.cat <- turbo(length(levels(tmp_cr[,"name"])))
# Add it to the dataframe
tmp_cr$colours <- col.cat[tmp_cr[,"name"]]
tmp_cr_shp$colours <- col.cat[tmp_cr_shp$name]

```

We currently have `r length(unique(tmp_cr$name))` devices transmitting data in Costa Rica:

```{r, echo=F}

# New map
ids <- tmp_cr_shp$name
names <- sub('\\_.*', '', tmp_cr_shp$name)
i <- 5
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_shp[i,], color = tmp_cr_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_cr$location_long[tmp_cr$name==ids[i]],
                         lat=tmp_cr$location_lat[tmp_cr$name==ids[i]], 
                         popup=paste(tmp_cr$timestamp[tmp_cr$name==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$name==ids[i]]), 
                         popup=paste(last(tmp_cr$timestamp[tmp_cr$name==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>% 
        # Add the last point
        addMarkers(lng=last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$name==ids[i]]), 
                         popup=paste(last(tmp_cr$local_identifier[tmp_cr$name==ids[i]]),
                                     "<br>Time:",last(tmp_cr$timestamp[tmp_cr$name==ids[i]]),
                                     "<br>Long:",last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                                     "<br>Lat:",last(tmp_cr$location_lat[tmp_cr$name==ids[i]])),
                   icon = iconSet[tmp_cr$icon[tmp_cr$name==ids[i]][1]], group=ids[i]) #, fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F
    }

  m <- m %>%
      # Add survey location
      addMarkers(lng=cr_locs$longitude,
                         lat=cr_locs$latitude, 
                         popup=cr_locs$location_code) %>% 
      #addLegend(position= "topright", colors=tmp_cr_shp$colours, 
       #         labels=names ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```

Daily schedule of the tags:
```{r, echo=F, warning=F, message=F}

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$name))

tmp_cr$hour <- as.numeric(substr(tmp_cr$timestamp,12,13))
tmp_cr$hour <- factor(tmp_cr$hour, levels=0:23)
tmp_cr$name <- as.factor(tmp_cr$name)
tmp_cr2 <- tmp_cr %>% group_by(name, hour, .drop=F) %>% dplyr::summarize(obs=n())

# Tag activity - account for survey effort
tmp_act_cr <- tmp_cr %>% group_by(name, .drop=F) %>% dplyr::summarize(start=min(timestamp), end=max(timestamp))

tmp_act_cr$duration <- as.numeric(difftime(tmp_act_cr$end, tmp_act_cr$start, units="days"))
tmp_cr2 <- tmp_cr %>% group_by(name, hour, .drop=F) %>% dplyr::summarize(obs=n())

tmp_cr2 <- left_join(tmp_cr2, tmp_act_cr)

tmp_cr2$sampling_rate <- tmp_cr2$obs/tmp_cr2$duration

# Add in the colour code
cols <- col.cat[1:length(levels(tmp_cr2$name))]


fig <- plot_ly(tmp_cr2, x = ~hour, y = ~sampling_rate, name = tmp_cr2$name, type = 'scatter', mode = 'lines',split = ~name,color=~name, colors=cols) 
fig <- fig %>%  layout(title = "Average hourly locations (last 14 days)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Locations per hour"))

fig



```

*Peru*

```{r, echo=F}
tmp_peru <- dat[dat$country=="peru",]
tmp_peru_shp <- dat_shp[dat_shp$country=="peru",]


# First lets choose a category to colour
tmp_peru[,"name"] <- factor(tmp_peru[,"name"])
tmp_peru_shp$name <- factor(tmp_peru_shp$name)

col.cat <- turbo(length(levels(tmp_peru[,"name"])))
# Add it to the dataframe
tmp_peru$colours <- col.cat[tmp_peru[,"name"]]
tmp_peru_shp$colours <- col.cat[tmp_peru_shp$name]

```

We currently have `r length(unique(tmp_peru$name))` devices transmitting data in Peru:

```{r, echo=F, eval=F}
# Old map
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%     
  addCircleMarkers(lng=tmp_peru$location_long, lat=tmp_peru$location_lat,
                   # Colour the markers depending on the 'feature type'
                   color=tmp_peru$colours,
                   radius=3,
                   stroke=F,
                   # Add a popup of the deployment code 
                   popup=paste(tmp_peru$name, tmp_peru$timestamp)) %>%
  addPolylines(data=tmp_peru_shp, color = tmp_peru_shp$colours, weight = 1, smoothFactor = 0.5,
              opacity = 1.0, fillOpacity = 0.5) %>% 
  # Add a legend explaining what is going on
  addLegend("bottomright", colors = col.cat,  labels = levels(tmp_peru[,"name"]),
            title = "Name",
            labFormat = labelFormat(prefix = "$"),
            opacity = 1
  ) %>%
  # add a layer control box to toggle between the layers
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addFullscreenControl()
m
```



```{r, echo=F}
# New map
ids <- tmp_peru_shp$name
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_shp[i,], color = tmp_peru_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru$location_long[tmp_peru$name==ids[i]],
                         lat=tmp_peru$location_lat[tmp_peru$name==ids[i]], 
                         popup=paste(tmp_peru$timestamp[tmp_peru$name==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru$location_long[tmp_peru$name==ids[i]]),
                         lat=last(tmp_peru$location_lat[tmp_peru$name==ids[i]]), 
                         popup=paste(last(tmp_peru$timestamp[tmp_peru$name==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F)  %>% 
        # Add the last point
        addMarkers(lng=last(tmp_peru$location_long[tmp_peru$name==ids[i]]),
                         lat=last(tmp_peru$location_lat[tmp_peru$name==ids[i]]), 
                         popup=paste(last(tmp_peru$local_identifier[tmp_peru$name==ids[i]]),
                                     "<br>Time:",last(tmp_peru$timestamp[tmp_peru$name==ids[i]]),
                                     "<br>Long:",last(tmp_peru$location_long[tmp_peru$name==ids[i]]),
                                     "<br>Lat:",last(tmp_peru$location_lat[tmp_peru$name==ids[i]])),
                   icon = iconSet[tmp_peru$icon[tmp_peru$name==ids[i]][1]], group=ids[i]) #, fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F
    }
    
  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```



Daily schedule of the tags:

```{r, echo=F, warning=F, message=F}

tmp_peru$hour <- as.numeric(substr(tmp_peru$timestamp,12,13))
tmp_peru$hour <- factor(tmp_peru$hour, levels=0:23)

tmp_peru$name <- as.factor(tmp_peru$name)

tmp_peru2 <- tmp_peru %>% group_by(name, hour, .drop=F) %>% dplyr::summarize(obs=n())


fig <- plot_ly(tmp_peru2, x = ~hour, y = ~obs, name = tmp_peru2$name, type = 'scatter', mode = 'lines',split = ~name) 
fig <- fig %>%  layout(title = "Hourly locations",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Number of locations"))

fig

```

# Last locations  {.tabset}

The following maps relate to just the last 48 hours of data for actively transmitting vultures, the last 2 weeks of data for actively transmitting mammals.  

### Costa Rica

```{r, echo=F, message=F, warning=F}
# Last 48 hours
# Vulture
tmp_cr_48 <- dat[dat$country=="costa_rica" & dat$timestamp > max(animals$timestamp_end, na.rm=T)-48*60*60 & dat$taxon_canonical_name %in% c("Cathartes aura" ,"Cathartes melambrotus", "Sarcoramphus papa", "Coragyps atratus"),]
#Mammals
tmp_48 <- dat[dat$country=="costa_rica" & dat$timestamp > max(animals$timestamp_end, na.rm=T)-336*60*60 & !(dat$taxon_canonical_name %in% c("Cathartes aura" ,"Cathartes melambrotus", "Sarcoramphus papa", "Coragyps atratus")),]

tmp_cr_48 <- rbind(tmp_48, tmp_cr_48)



tmp_cr_48$name <- as.character(tmp_cr_48$name)
#table(dat$taxon_canonical_name)
# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_cr_48, tmp_cr_48$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_cr_48_shp <- st_sf(data.frame(name=levels(factor(tmp_cr_48[,"name"])), geom=lfc))

# add back in the metadata
tmp_cr_48_shp  <- left_join(tmp_cr_48_shp,sp_dat)





# First lets choose a category to colour
tmp_cr_48[,"name"] <- factor(tmp_cr_48[,"name"])
tmp_cr_48_shp$name <- factor(tmp_cr_48_shp$name)

col.cat <- turbo(length(levels(tmp_cr_48[,"name"])))
# Add it to the dataframe
tmp_cr_48$colours <- col.cat[tmp_cr_48[,"name"]]
tmp_cr_48_shp$colours <- col.cat[tmp_cr_48_shp$name]

```

We currently have `r length(unique(tmp_cr$name))` devices actively transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_cr_48_shp$name
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_48_shp[i,], color = tmp_cr_48_shp$colours[i], group = ids[i], weight=2,opacity=0.5)         %>%
        
        # All points
        addCircleMarkers(lng=tmp_cr_48$location_long[tmp_cr_48$name==ids[i]],
                         lat=tmp_cr_48$location_lat[tmp_cr_48$name==ids[i]], 
                         
                         popup=paste(tmp_cr_48$local_identifier[tmp_cr_48$name==ids[i]],
                                     "<br>Time:",tmp_cr_48$timestamp[tmp_cr_48$name==ids[i]],
                                     "<br>Long:",tmp_cr_48$location_long[tmp_cr_48$name==ids[i]],
                                     "<br>Lat:",tmp_cr_48$location_lat[tmp_cr_48$name==ids[i]]),
                         
                         fillOpacity = 0.3, opacity = 0.5, radius=3, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F) %>%
        
        # The last point
        addMarkers(lng=last(tmp_cr_48$location_long[tmp_cr_48$name==ids[i]]),
                         lat=last(tmp_cr_48$location_lat[tmp_cr_48$name==ids[i]]), 
                         popup=paste(last(tmp_cr_48$local_identifier[tmp_cr_48$name==ids[i]]),
                                     "<br>Time:",last(tmp_cr_48$timestamp[tmp_cr_48$name==ids[i]]),
                                     "<br>Long:",last(tmp_cr_48$location_long[tmp_cr_48$name==ids[i]]),
                                     "<br>Lat:",last(tmp_cr_48$location_lat[tmp_cr_48$name==ids[i]])),
                   icon = iconSet[tmp_cr_48$icon[tmp_cr_48$name==ids[i]][1]], group=ids[i]) #, fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F
    }

  m <- m %>%
      # Add survey location
      addMarkers(lng=cr_locs$longitude,
                         lat=cr_locs$latitude, 
                         popup=cr_locs$location_code) %>% 
      #addLegend(position= "topright", colors=tmp_cr_48_shp$colours, 
      #          labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple", "OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 
```


### Peru

```{r, echo=F, message=F, warning=F}
# Subset to 48 hours
tmp_peru_48 <- dat[dat$country=="peru" & dat$timestamp > max(ymd_hms(animals$timestamp_end),na.rm=T)-48*60*60,]

tmp_peru_48$name <- as.character(tmp_peru_48$name)

# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_peru_48, tmp_peru_48$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_peru_48_shp <- st_sf(data.frame(name=levels(factor(tmp_peru_48[,"name"])), geom=lfc))

# add back in the metadata
tmp_peru_48_shp  <- left_join(tmp_peru_48_shp,sp_dat)


# First lets choose a category to colour
tmp_peru_48[,"name"] <- factor(tmp_peru_48[,"name"])
tmp_peru_48_shp$name <- factor(tmp_peru_48_shp$name)

col.cat <- turbo(length(levels(tmp_peru_48[,"name"])))
# Add it to the dataframe
tmp_peru_48$colours <- col.cat[tmp_peru_48[,"name"]]
tmp_peru_48_shp$colours <- col.cat[tmp_peru_48_shp$name]

```

We currently have `r length(unique(tmp_peru$name))` devices transmitting data in Peru:

```{r, echo=F}
# New map
ids <- tmp_peru_48_shp$name
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_48_shp[i,], color = tmp_peru_48_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru_48$location_long[tmp_peru_48$name==ids[i]],
                         lat=tmp_peru_48$location_lat[tmp_peru_48$name==ids[i]], 
                         popup=paste(tmp_peru_48$timestamp[tmp_peru_48$name==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru_48$location_long[tmp_peru_48$name==ids[i]]),
                         lat=last(tmp_peru_48$location_lat[tmp_peru_48$name==ids[i]]), 
                         popup=paste(last(tmp_peru_48$timestamp[tmp_peru_48$name==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F) %>%
        
        # The last point
        addMarkers(lng=last(tmp_peru_48$location_long[tmp_peru_48$name==ids[i]]),
                         lat=last(tmp_peru_48$location_lat[tmp_peru_48$name==ids[i]]), 
                         popup=paste(last(tmp_peru_48$local_identifier[tmp_peru_48$name==ids[i]]),
                                     "<br>Time:",last(tmp_peru_48$timestamp[tmp_peru_48$name==ids[i]]),
                                     "<br>Long:",last(tmp_peru_48$location_long[tmp_peru_48$name==ids[i]]),
                                     "<br>Lat:",last(tmp_peru_48$location_lat[tmp_peru_48$name==ids[i]])),
                   icon = iconSet[tmp_peru_48$icon[tmp_peru_48$name==ids[i]][1]], group=ids[i])
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_48_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple", "OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```

# Cluster detection

The following map shows all of the vulture clusters which have occurred in the previous 72 hours. This map should be checked daily to find potential feeding sites for visual confirmation. The field team should:

- Prioritize recent clusters - we are more likely to find a carcass if a vulture was feeding recently

- Prioritize accessible clusters - not all of these clusters will be accessible, you should figure out which would be the easiest to visit

- Prioritize clusters with multiple individuals - if more than one individual has visited a cluster, this could suggest a large feeding event

Key:

- Colored circles denote clusters of > than 1 hour duration, where the vultures have low distances travelled

- The colors denote how recently the cluster started (Red >24 hours; orange 24-48 hours; blue 48-72 hours)

- Hover over the circle for gps coordinates, cluster radius, number of points in the cluster and duration of the event

### Costa Rica
```{r, eval=T, echo=F, message=F, warning=F}
# Code derived from
# https://github.com/movestore/Daily-Rest-Sites
#library('maptools')
#library('ggmap')


# Subset to costa rica and vultures
sub_dat <- mov_dat[mov_dat$location_lat>0 ,]

# Just pull last 3 days
start_t2 <- t-as.difftime(3,units='days')
sub_dat <- sub_dat[sub_dat$timestamp>start_t2,]

sub_dat$speed <- unlist(lapply(move::speed(sub_dat),c, NA ))
sub_dat_df <- as.data.frame(sub_dat)
sub_dat_df <- left_join(sub_dat_df, animals[, c("tag_id", "name", "taxon_canonical_name")])

# Subset to just vultures
sub_dat_df <- sub_dat_df[sub_dat_df$taxon_canonical_name %in% c("Cathartes aura", "Sarcoramphus papa"),]


sub_dat_df <- sub_dat_df[order(sub_dat_df$name),]

# Add in icon column
sub_dat_df$icon <- sub(".*? ", "", sub_dat_df$taxon_canonical_name)




lfc <- do.call(st_sfc,
              lapply(split(sub_dat_df, sub_dat_df$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(name=levels(factor(sub_dat_df[,"name"])), geom=lfc))

#plot(st_geometry(dat_shp))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

# Bring in the colours from earlier
cr_cols <- tmp_cr[, c("name", "colours")]
cr_cols <- cr_cols[duplicated(cr_cols)==F,]
dat_shp <- left_join(dat_shp, cr_cols)
# Make shapefile of the tracks to add later

#plot(sub_dat_df$ground_speed, sub_dat_df$speed)
#plot(sub_dat_df$ground_speed, sub_dat_df$height_above_ellipsoid)

#plot(sub_dat, col=as.numeric(sub_dat$ground_speed<1)+1)
#plot(sub_dat[sub_dat$ground_speed<1,], add=T)



# Specifiy the settings

data=sub_dat
window="sunupdown"
upX=0
downX=0
speedvar="speed"
maxspeed=0.2

duration=1.2
radius=100


#rFunction <- function(data, window="all", upX=0, downX=0, speedvar="speed", maxspeed=NULL, duration=NULL, radius=NULL)
#{
  Sys.setenv(tz="America/Costa_Rica")
  
  names(data) <- make.names(names(data),allow_=FALSE)
  
  # add species info
  data.df <- as.data.frame(data)
  names(data.df) <- make.names(names(data.df),allow_=FALSE)
  #if (any(names(data.df)=="individual.taxon.canonical.name")) data@data$species <- data.df$individual.taxon.canonical.name
  data@data$species <- data.df$taxon.canonical.name
  
  speedx <- function(x) #input move object
  {
    N <- length(x)
    distVincentyEllipsoid(coordinates(x))/as.numeric(difftime(timestamps(x)[-1],timestamps(x)[-N],units="secs"))
  }

  n.all <- length(timestamps(data))
  data <- data[!duplicated(paste0(round_date(timestamps(data), "5 mins"), trackId(data))),]
  
    data.split <- move::split(data)
    data.ground <- foreach(datai = data.split) %do% {
        if (speedvar=="speed") 
        {
          if (length(datai)>1) #cannot calculated between-loc speed if only one location, therefore keep
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
 #           logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        } else if (speedvar %in% names(datai)) 
        {
          res <- datai[datai@data[,speedvar]<maxspeed | is.na(datai@data[,speedvar]),] # this allows also NA speed to be selected
#          logger.info("Your speed variable contains NA, these are kept in the data set of rest positions.")
        } else 
        {
#          logger.info("You have not selected a viable speed variable. Therefore the fallback between location speed is calculated.")
          if (length(datai)>1)
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
#            logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        }
        res
    }
    names(data.ground) <- names(data.split)
    data.ground <- moveStack(data.ground[unlist(lapply(data.ground, length) > 0)])
    
    # select night or day positions (use data.ground, call it "night")
    data.ground.split <- move::split(data.ground)
    data.night <- foreach(data.groundi = data.ground.split) %do% {
      #print(namesIndiv(data.groundi))
      sunupx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunrise", POSIXct.out=TRUE))$time + upX*60
      sundownx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunset", POSIXct.out=TRUE))$time + downX*60
      data.groundi@data <- cbind(data.groundi@data,sunupx,sundownx)

      ix <- which(is.na(sunupx) | is.na(sundownx))
      
      ix_ArcSum <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_ArcWin <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      ix_AntWin <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_AntSum <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      
      if (window=="all")
      {
        data.nighti <- data.groundi
        year <- as.POSIXlt(timestamps(data.nighti))$year+1900
        yday <- as.POSIXlt(timestamps(data.nighti))$yday
        data.nighti@data <- cbind(data.nighti@data,year,yday)
      } else
      {
        if (window=="sundownup") #night roosts
        {
          if (length(ix_ArcSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcSum,]
          }
          if (length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntSum,]
          }
          
          if (length(ix_ArcWin)>0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) and", length(ix_AntWin), " southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin,ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin,ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin,ix_AntWin)),]
          } else if (length(ix_ArcWin)>0 & length(ix_AntWin)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin)),]
          } else if (length(ix_ArcWin)==0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntWin)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)<=data.groundi$sunupx | timestamps(data.groundi)>=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          ynight <- yday
          
          ixx <- which(is.na(data.nighti$sundownx))
          if (length(ixx)>0)
          {
            ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]] <- ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]]+1
            
            # for Arctic/Antarctic nights the night goes from midday to midday, which depends on the location..
            midday_ixx <- solarnoon(coordinates(data.nighti[ixx]),timestamps(data.nighti[ixx]),POSIXct.out=TRUE)$time
            ynight[timestamps(data.nighti[ixx])>midday_ixx] <- ynight[timestamps(data.nighti[ixx])>midday_ixx]+1
          } else ynight[timestamps(data.nighti)>data.nighti$sundownx] <- ynight[timestamps(data.nighti)>data.nighti$sundownx]+1
          
          # adapt for New Year's Eve
          year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx]+1
          ynight[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- 0
          
          data.nighti@data <- cbind(data.nighti@data,year,yday,ynight)
        }
        
        if (window=="sunupdown") # day rests
        {
          if (length(ix_ArcWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcWin,]
          }
          if (length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntWin,]
          }
          
          if (length(ix_ArcSum)>0 & length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) and", length(ix_AntSum), " southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum,ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum,ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum,ix_AntSum)),]
          } else if (length(ix_ArcSum)>0 & length(ix_AntSum)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum)),]
          } else if (length(ix_ArcSum)==0 & length(ix_AntSum)>0)
          {
#            logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntSum)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)>=data.groundi$sunupx & timestamps(data.groundi)<=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          data.nighti@data <- cbind(data.nighti@data,year,yday)
        }
      }
      return(data.nighti)   
    }
    if (is(data.night,'Move')) data.night <- moveStack(data.night,forceTz="America/Costa_Rica") #force to movestack
    names (data.night) <- names(data.ground.split)
    data.night.nozero <- data.night[unlist(lapply(data.night, length) > 0)]
    
    {
      data.night <- moveStack(data.night.nozero)
      data.night.df <- as.data.frame(data.night)
      nacolx <- which(apply(data.night.df,2,function (x) all(is.na(x))))
      if (length(nacolx)>0) data.night.df.nna <- data.night.df[,-nacolx] else data.night.df.nna <- data.night.df #remove columns with all NA
      
      #write.csv(data.night.df.nna,file = paste0("data_rest_selectedTime.csv"),row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      #write.csv(data.night.df.nna,file = "data_rest_selectedTime.csv",row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      
      # save all rest positions if is rest by given definition (radius, duration), goes backwards for last night/day rest
      data.night.split <- move::split(data.night)
      
      if (window=="all")
      {
        prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      } else
      {
        if (window=="sundownup") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"ynight"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
        if (window=="sunupdown") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      }
      
      data.rest <- foreach(data.nighti = data.night.split) %do% {
#        logger.info(paste("Extracting rest sites of",namesIndiv(data.nighti)))
        data.resti.df <- data.frame(as.data.frame(moveStack(data.nighti)),coordinates(data.nighti))[0,] #empty df to fill, moveStack to keep trackId
        Nresti <- dim(data.resti.df)[2]
        names(data.resti.df)[(Nresti-1):Nresti] <- c("location.long","location.lat")
        
        year <- unique(data.nighti@data$year)
        for (k in seq(along=year))
        {
          
          data.nightik <- data.nighti[data.nighti@data$year==year[k],]
          
          if (window=="all")
          {
            night <- unique(data.nightik@data$yday)
          } else
          {
            if (window=="sundownup") night <- unique(data.nightik@data$ynight)
            if (window=="sunupdown") night <- unique(data.nightik@data$yday)
          }
          
          for (j in seq(along=night))
          {
            
            if (window=="all")
            {
              data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            } else
            {
              if (window=="sundownup") data.nightikj <- data.nightik[data.nightik@data$ynight==night[j],]
              if (window=="sunupdown") data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            }
            
            last <- Nikj <- length(data.nightikj)
            while (last>1) # as long as first night/day position is not the last
            {
              data.nightikj <- data.nightikj[1:last,]
              backdt <- as.numeric(difftime(timestamps(data.nightikj)[last],timestamps(data.nightikj)[-c(last:Nikj)],units="hours"))
              if (length(backdt)>=1) #changed this to allow for further away position (if in radius assume not moved), allows for worse resolution data
              {
                # note that here not yet checked that duration in site complete, later
                if (any(backdt<=duration)) 
                {
                  data.sel <- data.nightikj[c(which(backdt<=duration),last),] 
                  #data.sel$timestamp
                  data.rem <- data.nightikj[-c(which(backdt<=duration),last),]
                  #data.rem$timestamp
                  #plot(data.nightikj$location.long, data.nightikj$location.lat)
                  #points(data.sel$location.long, data.sel$location.lat, col="green")
                  #points(data.rem$location.long, data.rem$location.lat, col="red")
                  
                } else
                {
                  data.sel <- data.nightikj[(last-1):last,]
                  data.rem <- data.nightikj[-c((last-1):last),]
                  
                }
                m <- colMeans(coordinates(data.sel))
                dp0 <- distVincentyEllipsoid(m,coordinates(data.sel))
                p0 <- coordinates(data.sel)[min(which(dp0==max(dp0))),]
                dp1 <- distVincentyEllipsoid(p0,coordinates(data.sel))
                p1 <- coordinates(data.sel)[min(which(dp1==max(dp1))),]
                maxdist <- distVincentyEllipsoid(p0,p1)
                
                if (maxdist<radius)
                {
                  ## check if already longer at this rest site
                  mid <- midPoint(p0,p1)
                  #points(mid[1], mid[2], col="blue")
                  data.bef <- data.rem
                  if (length(data.bef)>=1)
                  {
                    dist.bef <- distVincentyEllipsoid(mid,coordinates(data.bef))
                    if (any(dist.bef>radius))
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      
                    } else 
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration),which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration),which(backdt<=duration),last),]
                    }
                  } else 
                  {
                    data.selx <- data.sel
                    data.remx <- data.rem
                  }
                  
                  data.selx.df <- data.frame(as.data.frame(moveStack(data.selx)),coordinates(data.selx))
                  # Check what is in there
                  #points(data.selx.df$location.long, data.selx.df$location.lat, col="yellow", pch=19)
                  # looks good
                  
                  Nselx <- dim(data.selx.df)[2]
                  names(data.selx.df)[(Nselx-1):Nselx] <- c("location.long","location.lat")
                  
                  time0 <- min(timestamps(data.selx))
                  timeE <- max(timestamps(data.selx))
                  durx <- as.numeric(difftime(timeE,time0,unit="hour"))
                  radx <- max(distVincentyEllipsoid(mid,coordinates(data.selx)))
                  
                  if (durx>=duration & radx<=radius) #added this condition to only save rest sites of given duration (if this condition is left out also rest site with shorter duration are given back)
                  {
                    data.resti.df <- rbind(data.resti.df,data.selx.df)
                    #points(data.resti.df$location.long, data.resti.df$location.lat, pch="x")
                    
                    
                    if (window=="all")
                    {
                      prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species,"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    } else
                    {
                      if (window=="sundownup") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"ynight"=data.selx.df$ynight[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                      if (window=="sunupdown") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    }
                  }
                  
                  
                  data.nightikj <- data.remx
                  #points(data.nightikj$location.long, data.nightikj$location.lat, pch="w")
                  
                  last <- Nikj <- length(data.nightikj) #this can be zero, will be stop indication in while() condition
                  
                } else last <- last-1 #shift one time step
              } else last <- last-1 # shift one time step also if not enough data in previous Xh time frame
            } #while
          } #for j
        } #for k
        if (dim(data.resti.df)[1]>0) 
        {
          o <- order(data.resti.df$timestamp)
          data.resti <- move(x=data.resti.df$location.long[o],y=data.resti.df$location.lat[o],time=as.POSIXct(data.resti.df$timestamp[o]),data=data.resti.df[o,],sensor=data.resti.df$sensor[o],animal=data.resti.df$trackId[o])
          
        } else data.resti <- NULL
      }
      names(data.rest) <- names(data.night.split)
      data.rest.nozero <- data.rest[unlist(lapply(data.rest, length) > 0)] #remove IDs with no data
      
      if (length(data.rest.nozero)==0) 
      {
#        logger.info("Your output file contains no positions. No csv overview and plot saved. Return NULL.")
        result <- NULL
      } else 
      {
        result <- moveStack(data.rest.nozero)
        #write.csv(prop.rest.df,file = paste0("rest_overview.csv"),row.names=FALSE) #csv artefakt
        #write.csv(prop.rest.df,file = "rest_overview.csv",row.names=FALSE)
        
        
                #map <- get_map(bbox(extent(data)),source="stamen",force=TRUE)
        
        #data.df <- data.frame(coordinates(data),as.data.frame(moveStack(data)))
        #names(data.df)[1:2] <- c("location.long0","location.lat0")
        
        #out <- ggmap(map) +
        #  geom_path(data=data.df,aes(x=location.long0,y=location.lat0,group=trackId),colour="blue") +
        #  geom_point(data=prop.rest.df,aes(x=rest.mean.long,y=rest.mean.lat),colour="red",size=3)

                #ggsave(out, file = paste0("rest_sites_onTracks.pdf"))
        
        # note that all timestamps are UTC!
      }
    }
  #}
  #return(result)
#test <- as.data.frame(result)
#plot(result)
#str(test)

#
clus_res <- prop.rest.df

# Add a colour colum
clus_age <- t-ymd_hms(clus_res$timestamp.last)
clus_res$col <- NA
clus_res$col[clus_age<24] <- "red"
clus_res$col[clus_age>24 & clus_age<48] <- "orange"
clus_res$col[clus_age>48] <- "blue"

# Convert the timestamps
clus_res$timestamp.first <- with_tz(ymd_hms(clus_res$timestamp.first), tz="America/Costa_Rica")
clus_res$timestamp.last <- with_tz(ymd_hms(clus_res$timestamp.last), tz="America/Costa_Rica")
clus_res$code <- paste0(toupper(substr(clus_res$local.identifier,1,3)),"_", substr(clus_res$timestamp.first,12,13),substr(clus_res$timestamp.first,3,4),substr(clus_res$timestamp.first,6,7),substr(clus_res$timestamp.first,9,10))  

# # Leaflet the data and add the output
# cols <- c("red", "blue")
# 
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat$ground_speed<1)+1]) 
# 
#  m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat_df$speed<0.1)+1]) 
# 
# m 
#  
#    
#   m <- m %>%
#         addCircleMarkers(lng=tmp$rest.mean.long,
#                          lat=tmp$rest.mean.lat, 
#                          popup=paste("duration =",tmp$rest.duration, "npos =",tmp$rest.nposi),
#                          fillOpacity = 0.3, opacity = 0.7, radius=4, color="orange") 
# 
# m  
 
m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addPolylines(data = dat_shp, color = dat_shp$colours, weight=3,opacity=0.3, popup=dat_shp$name) %>% 
        addCircleMarkers(lng=clus_res$rest.mean.long,
                         lat=clus_res$rest.mean.lat, 
                         popup=paste("name"=clus_res$local.identifier, 
                                     "<br>duration =",round(clus_res$rest.duration,1), "h", 
                                     "<br>time =",substr(clus_res$timestamp.first, 12,16), "-", substr(clus_res$timestamp.last, 12,16),
                                     "<br>npos =",clus_res$rest.nposi, " Radius =" ,round(clus_res$rest.radius,1),"m",
                                     "<br>lon =" ,round(clus_res$rest.mean.lon,6)  , "lat =", round(clus_res$rest.mean.lat,6),
                                     "<br>code =", clus_res$code) 
                                     ,
                          fillOpacity = 0.3, opacity = 0.7, radius=4, color=clus_res$col)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
      )  %>% 
    addLegend(position="topright", labels=c("<24", "24-48", "48+"), colors=c("red","orange","blue"), title="Cluster age")

ids <- unique(sub_dat_df$name)  

  for(i in 1:length(ids))      
        # The last point
  m <-   m %>%   addMarkers(lng=last(sub_dat_df$location_long[sub_dat_df$name==ids[i]]),
                         lat=last(sub_dat_df$location_lat[sub_dat_df$name==ids[i]]), 
                         popup=paste(last(sub_dat_df$local_identifier[sub_dat_df$name==ids[i]]),
                                     "<br>Time:",last(sub_dat_df$timestamp[sub_dat_df$name==ids[i]]),
                                     "<br>Long:",last(sub_dat_df$location_long[sub_dat_df$name==ids[i]]),
                                     "<br>Lat:",last(sub_dat_df$location_lat[sub_dat_df$name==ids[i]])),
                   icon = iconSet[sub_dat_df$icon[sub_dat_df$name==ids[i]][1]], group=ids[i])%>%
  addFullscreenControl()
  
  
  m


# Also include night'time sleep locations? Would that be useful?

# Cluster map

# - Nighttime locations
# - Last 72 hours - can we colour code --> based on recent locations 
# - Work flow
# Open cluster tab
# Identify accessible clusters
  # Gps points
  # Size of the spread
# Make sure 
# Cheris look at master protocol --> 
  
```




The following is a list of all of the clusters in the above map, ordered by age (newest first):

```{r, echo=F, warning=F, message=F}
 tmp <- clus_res[,c("local.identifier","timestamp.first", "rest.mean.long", "rest.mean.lat", "rest.nposi", "rest.duration", "code")]
 tmp <- tmp[order(tmp$timestamp.first, decreasing=T),]
  colnames(tmp) <- c("name", "start_time", "long", "lat", "npos", "duration", "code")
 tmp$duration <- round(tmp$duration,1)

  tmp %>%
  kbl(row.names = FALSE) %>%
  kable_styling()  %>%
  kableExtra::scroll_box(width = "100%")

```


```{r, echo=F, eval=F}
# TRy a different option



library(geosphere)
library(suncalc)
library(purrr)
library(plyr)
library(move)
library(sf)
library(tmap)
library(dplyr)

# \describe{
#   \item{individual.local.identifier}{Animal identification}
#   \item{clus_ID}{Sequential cluster ID number}
#   \item{clus_start}{Timestamp of first location in cluster}
#   \item{clus_end}{Timestamp of last location in cluster}
#   \item{clus_status}{"Closed" if the time window (window_days) has expired for the cluster according to users Sys.time() output.
#                      These clusters are therefore solidified and should not change if appending new location data.
#                      "Open" if the time window remains open at the time the function was run. "Open" clusters have the ability
#                      to shift sequence, combine with other clusters, emerge as a new cluster, etc. This attribute becomes
#                      relevant when appending new satellite data to the location dataframe, and may serve as an index of whether
#                      an animal continues to actively visit the cluster site within the time window.}
#   \item{g_c_Long}{Geometic centroid longitude value calculated using the mean}
#   \item{g_c_Lat}{Geometic centroid latitude value calculated using the mean}
#   \item{g_med_Long}{Geometic centroid longitude value calculated using the median}
#   \item{g_med_Lat}{Geometic centroid latitude value calculated using the median}
#   \item{clus_dur_hr}{Hours from the first to last locations of the cluster}
#   \item{n_clus_locs}{Number of locations within the cluster}
#   \item{visits}{Number of visits/revisits to the cluster based on the number of times locations fall outside the search radius and return
#                 to add locations to the cluster}
#   \item{max_foray}{Maximum location distance (meters) from centroid during cluster duration for all locations}
#   \item{clus_radius}{Maximum location distance (meters) from centroid during cluster duration for cluster-attributed locations}
#   \item{avg_clus_dist}{Mean distance from all cluster locations to centroid}
#   \item{night_pts}{Number of night cluster locations based on 'daylight_hrs' argument}
#  \item{night_prop}{Proportion of night cluster locations}
#}

######################################################################################

#search_radius: Search radius (meters) from cluster centroid when building clusters.
#window_days: window (days) to search for new locations from the most recent location to form one cluster
#clus_min_locs: Minimum number of locations required to form a cluster. Default used is 2.
#centroid_calc: Method for recalculating centroids when actively building clusters - e.g., "median" or "mean" (default).

search_radius = 75
window_days = 1
clus_min_locs = 3
centroid_calc="mean"
daylight_hrs=NA
zz <- 1
rFunction <-function(data, search_radius, window_days, clus_min_locs, centroid_calc="mean",daylight_hrs=NA ){
  
  dat <-as.data.frame(data)
  names(dat) <- gsub("[.]", "_", names(dat))
  
  moveMe <- function(data, tomove, where = "last", ba = NULL) {
    temp <- setdiff(names(data), tomove)
    x <- switch(
      where,
      first = data[c(tomove, temp)],
      last = data[c(temp, tomove)],
      before = {
        if (is.null(ba)) stop("must specify ba column")
        if (length(ba) > 1) stop("ba must be a single character string")
        data[append(temp, values = tomove, after = (match(ba, temp)-1))]
      },
      after = {
        if (is.null(ba)) stop("must specify ba column")
        if (length(ba) > 1) stop("ba must be a single character string")
        data[append(temp, values = tomove, after = (match(ba, temp)))]
      })
    x
  }
  
  dat<-dat[order(dat$trackId,dat$timestamp),]     #make sure we have this line active in final function, hashed for testing
  #set up location data output with cluster number attribute
  dat2<-dat[1,]
  dat2$clus_ID<-NA
  dat2<-dat2[-1,]
  uni_individual.local.identifier<-as.character(unique(dat$trackId))            #loop through individual.local.identifiers
  zz
    for(zz in 1:length(uni_individual.local.identifier)) {                        #start loop
    out_all<-subset(dat, trackId == uni_individual.local.identifier[zz])                                    #get rows per individual.local.identifier
    
    
    plot(out_all$location_long, out_all$location_lat, main=out_all$local_identifier[1])
    
    if(length(which(is.na(out_all$location_lat)))==0){warning(paste(uni_individual.local.identifier[zz], "shows no missed locations. Ensure 'failed' fix attempts are included for accurate cluster attributes."))}
    #subset successful fixes for algorithm
    out<-out_all[which(!is.na(out_all$location_lat)),]                                   #subset only usable locations
    if(nrow(out)>0){
      ##############################################
      ###########Construct Primary Cluster Algorithm
      ##############################################
      #add/prep columns
      out$index<-seq(1:nrow(out))
      out$ClusID<-0
      out<-moveMe(out, "ClusID", "first")
      out<-moveMe(out, "index", "first")
      #first internal loop with windows progress bar and label by animal and process
      c<-1                                                                    #seed ticker for sequential cluster numbers
      #pb2 <- tcltk::tkProgressBar(min = 0, max = nrow(out), width = 500)
      j <- 1
      for(j in 1:nrow(out)){                                                  #for each sequential location
        if(out$ClusID[j] == 0){                                              #IF THE LOCATION HAS NOT BEEN ASSIGNED A CLUSTER
          cent<-c(out[j,"location_long"], out[j,"location_lat"])                                   #LL reference point location as cluster centroid
          t<- out[which(out$timestamp > out[j,"timestamp"] & out$timestamp <= out[j,"timestamp"] + as.difftime(window_days, units= "days")),] #create time window
          AR_Clus<- unique(t[which(t$ClusID >0),"ClusID"])                      #list of clusters IDs already formed within the time window
          for(m in 1:length(AR_Clus)){  #this small loop updates locations within the time window that already are clustered the centroid of thier clusters
            b<-out[which(out$ClusID == AR_Clus[m]),]                            #pull all the locations from that cluster
            if(nrow(t)>0){
              if(centroid_calc == "median"){
                t[which(t$ClusID == AR_Clus[m]),"location_long"]<-stats::median(b$location_long)             #recalc gc location_long   -- median --
                t[which(t$ClusID == AR_Clus[m]),"location_lat"]<-stats::median(b$location_lat)               #recalc gc location_lat
              } else {
                t[which(t$ClusID == AR_Clus[m]),"location_long"]<-mean(b$location_long)             #recalc gc location_long  -- mean --
                t[which(t$ClusID == AR_Clus[m]),"location_lat"]<-mean(b$location_lat)               #recalc gc location_lat
              }
            }
          }
          if(nrow(t)>0){
            t$centlocation_long<-cent[1]                                                   #LL attribute all point distances from cent
            t$centlocation_lat<-cent[2]
            t$dist<-geosphere::distm(cbind(t$centlocation_long,t$centlocation_lat), cbind(t$location_long,t$location_lat), fun = geosphere::distHaversine)[1,]
          }
          if(length(t[which(t$dis<=search_radius),"index"])>0){                           #if a point meets distance criteria
            if(out$ClusID[min(t[which(t$dist<search_radius),"index"])]==0){                #and if that candidate also has not been assigned
              out$ClusID[j]<-c                                                  #assign the reference point a new clusID
              out$ClusID[min(t[which(t$dist<search_radius),"index"])]<-c                   #also assign the candidate point the same ID to create the new cluster
              c<-c+1                                                            #then hit the ticker
            } else {                                                            #OR, if the candidate is already part of a cluster
              out$ClusID[j]<-out$ClusID[min(t[which(t$dist<search_radius),"index"])]       #just assign the point the candidate that cluster ID
            }
          }
        } else { #IF THE LOCATION HAS ALREADY BEEN ASSIGNED A CLUSTER - compare cluster centroid as reference point
          if(centroid_calc == "median"){
            cent<- c(stats::median(out[which(out$ClusID == out$ClusID[j]),"location_long"]),stats::median(out[which(out$ClusID == out$ClusID[j]),"location_lat"]))#recalc centroid --median--
          } else {
            cent<- c(mean(out[which(out$ClusID == out$ClusID[j]),"location_long"]),mean(out[which(out$ClusID == out$ClusID[j]),"location_lat"]))#recalc centroid --mean--
          }
          t<- out[which(out$timestamp > out[j,"timestamp"] & out$timestamp <= out[j,"timestamp"] + as.difftime(window_days, units= "days")),] #create time window
          AR_Clus<- unique(t[which(t$ClusID >0),"ClusID"])                      #same loop as before to update candidate cluster centers
          for(m in 1:length(AR_Clus)){
            b<-out[which(out$ClusID == AR_Clus[m]),]
            if(nrow(t)>0){
              if(centroid_calc == "median"){
                t[which(t$ClusID == AR_Clus[m]),"location_long"]<-stats::median(b$location_long)             #recalc gc location_long   -- median --
                t[which(t$ClusID == AR_Clus[m]),"location_lat"]<-stats::median(b$location_lat)               #recalc gc location_lat
              } else {
                t[which(t$ClusID == AR_Clus[m]),"location_long"]<-mean(b$location_long)             #recalc gc location_long  -- mean --
                t[which(t$ClusID == AR_Clus[m]),"location_lat"]<-mean(b$location_lat)               #recalc gc location_lat
              }
            }
          }
          if(nrow(t)>0){
            t$centlocation_long<-cent[1]                                                   #LL
            t$centlocation_lat<-cent[2]
            t$dist<-geosphere::distm(cbind(t$centlocation_long,t$centlocation_lat), cbind(t$location_long,t$location_lat), fun = geosphere::distHaversine)[1,]
          }
          if(length(t[which(t$dist<=search_radius),"index"])>0){                           #if a location meets distance criteria
            if(out$ClusID[min(t[which(t$dist<search_radius),"index"])]==0){                #and if that candidate also has not been assigned
              out$ClusID[min(t[which(t$dist<search_radius),"index"])]<- out$ClusID[j]      #assign candidate the reference cluster ID
            } else{ #if the candidate is also part of a cluster - we need to merge the clusters into one
              #the next line looks at all locations from both clusters for the minimum timestamp between them for that cluster ID
              merge_num<-out[which(out$timestamp == min(c(out[which(out$ClusID == out$ClusID[j]),"timestamp"],out[which(out$ClusID == out$ClusID[min(t[which(t$dist<search_radius),"index"])]),"timestamp"]))), "ClusID"]
              #then we attribute both clusters that ID
              out[which(out$ClusID == out$ClusID[j]),"ClusID"]<-merge_num
              out[which(out$ClusID == out$ClusID[min(t[which(t$dist<search_radius),"index"])]),"ClusID"]<-merge_num
              rm(merge_num)
            }
          }
        }
        
      }
      #rm(b,c,m,j,t,AR_Clus,cent) ### remove objects from the clustering steps
      
      ###################fin primary cluster algorithm
      see<-rle(out$ClusID)                                          #run the rle function, to get bouts of identical values (cluster IDs)
      bout_end<- cumsum(rle(out$ClusID)$lengths)                    #record the start row
      bout_start<- as.integer(c(1, bout_end +1))                    #and end row of each bout
      bout_start<- bout_start[-length(bout_start)]                  #remove the last start bout
      bout_start<-out$timestamp[bout_start]                         #convert bout starts to timestamps
      bout_end<-out$timestamp[bout_end]                             #convert bout ends to timestamps
      bout_duration<-round(difftime(bout_end, bout_start, units= "hours"),1)  #calculate bout durations
      bouts<-data.frame(bout_start,bout_end, bout_duration, see[["lengths"]], see[["values"]]) #merge into a new bouts dataframe
      names(bouts)[names(bouts) == "see...values..."]<- "ClusID"            #rename column for Cluster ID
      names(bouts)[names(bouts) == "see...lengths..."]<- "consec_locs"      #rename column for consective locations
      #rm(bout_start, bout_end, see)                                         #clear variables
      
      #we now have a dataframe that shows temporal bouts and number of locations in sequence
      #but these include non-cluster bouts and jump back and forth among cluster IDs
      bouts2<-subset(bouts, ClusID != 0)                            #so remove non-cluster bouts and put in new bout2 df
      bouts2<-bouts2[order(bouts2$ClusID, bouts2$bout_start),]      #sort by cluster ID and bout start
      #summarize clusters
      clus_summary<-plyr::ddply(bouts2, "ClusID", summarize,
                          clus_start= min(bout_start), clus_end= max(bout_end),
                          clus_dur_hr=round(difftime(max(bout_end), min(bout_start), units="hours"),1),
                          n_clus_locs= sum(consec_locs))
      #eliminate clusters that dont meet the required minimum number of locations
      clus_summary<-clus_summary[which(clus_summary$n_clus_locs >= clus_min_locs),]          #need to add a check below and ensure at least one cluster exists
      if(nrow(clus_summary)==0){
        warning(paste("Zero clusters identified for", uni_individual.local.identifier[zz], "given user-entered parameters."))
        out_all$clus_ID<-NA
      } else {
        #sort and relabel new clusters in sequence
        clus_summary<-clus_summary[order(clus_summary$clus_start),] #sort
        clus_summary$clus_ID3<-seq(1:nrow(clus_summary))
        clus_summary<-moveMe(clus_summary, "clus_ID3" , "first")
        
        #now reattribute cluster/revisit in bouts2
        bouts2$clus_ID3<-NA
        bouts2$clus_ID3<-clus_summary[match(bouts2$ClusID, clus_summary$ClusID), "clus_ID3"]  #match bouts with summary cluster numbers
        bouts2<-moveMe(bouts2, "clus_ID3" , "first")
        bouts2<-bouts2[order(bouts2$clus_ID3, bouts2$bout_start),] #sort by cluster ID and bout start
        clus_summary$ClusID<-NULL
        bouts2$ClusID<-NULL
        bouts2<-bouts2[which(!is.na(bouts2$clus_ID3)),]  #remove bouts associated with clusters that dont meet minimum point criteria
        #Calculate number of visits/revisits to each cluster and add as a cluster summary attribute
        see<-rle(bouts2$clus_ID3)         #run the fancy rle again to get the number of revisits
        clus_summary$visits<-see$lengths  #add number of visits to the cluster summary
        #now reattribute cluster IDs to the whole dataset including missed locations
        out_all$clus_ID3<-NA
        for(k in 1:nrow(bouts2)){
          out_all[which(out_all$timestamp >= bouts2$bout_start[k] & out_all$timestamp <= bouts2$bout_end[k]), "clus_ID3"]<- bouts2$clus_ID3[k]
        }
        #rm(k, bouts, bouts2, bout_duration, see, out)
        #relabel and clean up columns
        names(clus_summary)[names(clus_summary) == "clus_ID3"]<- "clus_ID"
        names(out_all)[names(out_all) == "clus_ID3"]<- "clus_ID"
        clus_summary$trackId<-out_all$trackId[1]
        clus_summary<-moveMe(clus_summary, "trackId", "first")
        
        #############fin with cluster identification###################################
        ###################Build Cluster Attributes for modeling######################
        #add which clusters are currently open during this system run time
        clus_summary$clus_status<-"Closed"
        clus_summary<-moveMe(clus_summary, "clus_status", "after", "clus_end")
        clus_summary[which(clus_summary$clus_end >= Sys.time() - as.difftime(window_days, units= "days")), "clus_status"]<- "Open"
        #calculate geometric center of clusters from cluster points and attribute to clus_summary    -- compare median vs mean location
        xxx<-plyr::ddply(out_all, "clus_ID", summarize,
                   g_c_location_long= mean(location_long, na.rm=TRUE), g_c_location_lat= mean(location_lat, na.rm=TRUE), 
                   g_med_location_long= stats::median(location_long, na.rm=TRUE), g_med_location_lat= stats::median(location_lat, na.rm=TRUE))
        xxx<-xxx[1:nrow(xxx)-1,] #remove the last row that summarizes non-cluster points
        clus_summary<-cbind(clus_summary, xxx[,2:5]) #bind to cluster summary
        clus_summary<-moveMe(clus_summary,c("g_c_location_long", "g_c_location_lat", "g_med_location_long", "g_med_location_lat"), "after", "clus_status")
        rm(xxx)
        
        #add some additional cluster attributes
        clus_summary$max_foray<-NA              # max distance from center cluster during cluster duration
        clus_summary$clus_radius<-NA            # max dist within cluster locs -cluster radius
        clus_summary$avg_clus_dist<-NA          # avg. dist from cluster locs to centroid
        # clus_summary$n_24_per<-NA               # number of 24 hr periods with cluster points over cluster duration
        # clus_summary$bin_24hr<-NA               # cluster points span less than or greater than one 24 hr period
        # clus_summary$season<-NA                 # seasons sequence based on julian breaks
        clus_summary$night_pts<-NA              # number of night cluster locs
        clus_summary$night_prop<-NA             # number night locs (1800-0600)/total cluster locs (night=0, day=1)
        #if(!is.na(season_breaks_jul[1])){clus_summary$season<-0}  #if the season argument exists, set all to reference season == 0 before loop
        #loop to calculate attributes
        #pb3 <- tcltk::tkProgressBar(min = 0, max = nrow(clus_summary), width = 500)
        for(i in 1:nrow(clus_summary)){
          ggg<-out_all[which(out_all$timestamp >= clus_summary$clus_start[i] & out_all$timestamp <= clus_summary$clus_end[i]),] #subset cluster fix attempts
          #clus_summary$fix_succ_clus_dur[i]<-round(nrow(ggg[which(!is.na(ggg$location_lat)),])/nrow(ggg),2)                              #prop fix success during cluster duration
          #clus_summary$adj_clus_locs[i]<- round(clus_summary$n_clus_locs[i] / clus_summary$fix_succ_clus_dur[i],1)              #adjusted cluster locations
          fff<-ggg[which(!is.na(ggg$location_lat)),]                                                                                     #subset cluster locations
          fff<-fff[which(fff$clus_ID != clus_summary$clus_ID[i] | is.na(fff$clus_ID)),]                                         #locations off cluster
          #clus_summary$fid[i]<- clus_summary$n_clus_locs[i] - nrow(fff)                                                         #locs on - locs off = Fidelity
          ggg$centlocation_long<-clus_summary[i, "g_c_location_long"]                                                                             #LL distances from centroid
          ggg$centlocation_lat<-clus_summary[i, "g_c_location_lat"]
          ggg$dist<-geosphere::distm(cbind(ggg$centlocation_long,ggg$centlocation_lat), cbind(ggg$location_long,ggg$location_lat), fun = geosphere::distHaversine)[1,]
          ggg$days<-difftime(ggg$timestamp, ggg$timestamp[1], units="days")                                                     #sets up 24 hr period covariates
          clus_summary$max_foray[i]<-round(max(ggg$dist, na.rm=T))                                                              #max foray distance from cluster
          clus_summary$clus_radius[i]<-round(max(ggg$dist[which(ggg$clus_ID == clus_summary$clus_ID[i])],na.rm=T))              #max dist of cluster locations = cluster radius
          clus_summary$avg_clus_dist[i]<- round(mean(ggg$dist[which(ggg$clus_ID == clus_summary$clus_ID[i])],na.rm=T))          #mean distance of cluster locations from center
          aa<-ggg[which(ggg$clus_ID == clus_summary$clus_ID[i]),]                                                               #subset cluster locs
          
          #day/night locations for each cluster
          aa<-aa[which(!is.na(aa$location_lat)),]
          if(!is.na(daylight_hrs[1])){
            #option to set own breaks for day v night locations
            aa$hour<-NA
            aa$hour<-as.numeric(format(aa$timestamp, format='%H'))
            clus_summary$night_pts[i]<-nrow(aa[which(aa$hour<=daylight_hrs[1] | aa$hour>=daylight_hrs[2]),])
            clus_summary$night_prop[i]<-round(clus_summary$night_pts[i] / clus_summary$n_clus_locs[i],2)
          } else{
            ttt<-aa[,c("timestamp", "location_long", "location_lat")]
            #since the format %Z occasionally returns multiple zones, we will use the attr() call
            #ttt$date<-as.Date(aa$timestamp, tz=(unique(base::format(out_all$timestamp, format="%Z"))))
            ttt$date<-as.Date(aa$timestamp, tz=attr(dat$timestamp,"tzone"))
            names(ttt)[names(ttt) == "location_lat"]<- "lat"
            names(ttt)[names(ttt) == "location_long"]<- "lon"
            #dd<-getSunlightTimes(data=ttt ,tz=(unique(base::format(out_all$timestamp, format="%Z")))) #get times
            dd<-suncalc::getSunlightTimes(data=ttt ,tz=attr(dat$timestamp,"tzone"))
            dd$timestamp<-aa$timestamp
            #determine night locations
            #aa$night<-dd %>% rowwise() %>% mutate(match = ifelse(between(timestamp, sunrise, sunset), 1, 0))# %>% select(match) #night=0, day=1
            aa$night<-ifelse(((dd$timestamp>=dd$sunrise) & (dd$timestamp<=dd$sunset)),1,0)
            clus_summary$night_pts[i]<-length(which(aa$night == 0))
            clus_summary$night_prop[i]<-round(clus_summary$night_pts[i] / clus_summary$n_clus_locs[i],2)
            rm(dd, ttt)
          }
          
        }
        rm(ggg, fff, aa, i)
        ####END cluster prep####
      }
      
      ######################################################################################
      #### Model output
      if(!exists("t_summ") & (ncol(clus_summary)==17)){
        t_summ<-clus_summary[1,]
        t_summ<-t_summ[-1,]
      }
      if(ncol(clus_summary)==17){
        t_summ<-rbind(t_summ, clus_summary)
      }
    } else {
      warning(paste(uni_individual.local.identifier[zz], "has no 'successful' fixes."))
      out_all$clus_ID<-NA
      if(!exists("dat2")){
        dat2<-out_all[1,]
        dat2<-out_all[-1,]
      }
    }
    dat2<-rbind(dat2,out_all)   #append dat2 with out_all data
    
  }
  
  dat<-dat2  #write the updated location output back to dat
  names(dat) <- make.names(names(dat2),allow_=FALSE)
  ###Converting the data.frame output into move-stack object
  data_move <- move(x=dat$location.long, y=dat$location.lat,
                    time=as.POSIXct(dat$timestamp,format="%Y-%m-%d %H:%M:%S"),
                    data=dat, proj=CRS("+proj=longlat +ellps=WGS84"),
                    animal=dat$tag.local.identifier)
  data_movestack <- moveStack(data_move,forceTz="UTC")
  rm(dat2)
  clus_summary<-t_summ  #write the cluster summary info back to clus_summary
  rm(zz, uni_individual.local.identifier, out_all, t_summ)
  
  ###### Convert the data into sf objects for plotting
  dat_sf <-st_as_sf(dat, coords=c("location.long", "location.lat"), crs=st_crs(4326))
  
  
  dat_sf_line <-dat_sf %>% group_by(trackId) %>% 
    summarise(do_union = FALSE) %>% st_cast("LINESTRING")
  clust_sf <-st_as_sf(clus_summary, coords=c("g_c_location_long", "g_c_location_lat"), crs=st_crs(4326))
  
  ##### plotting the clusters and animal tracks
  map_out_new <-  #tm_shape(dat_sf_line)+
    #tm_graticules()+
    #tm_lines(col ="grey")+
    tm_shape(clust_sf)+ tm_dots(col= "brown", scale=1.5)+
    tm_scale_bar(position = c("left", "bottom"), width = 0.5) +
    tm_compass(position = c("left", "top"), size = 4)
 
  tmap_save(map_out_new, width=12, height = 8, units = "in", dpi=300, 
            file= paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"),"Cluster_locations_plot.jpeg"))
  write.csv(clus_summary, file= paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"), "Cluster_summary_output.csv"),row.names=FALSE)
  #write.csv(clus_summary, file=  "Cluster_summary_output.csv",row.names=FALSE)
  return(data_movestack)
}


clus_summary_df <- as.data.frame(clus_summary)


# Must be at least an hour
hist(as.numeric(clus_summary_df$clus_dur_hr), breaks=seq(0,max(as.numeric(clus_summary_df$clus_dur_hr))+1, by=1))
clus_summary_df <- clus_summary_df[clus_summary_df$clus_dur_hr>1,]


# Add a colour colum
t <- now("America/Costa_Rica")
clus_age <- t-clus_summary_df$clus_end
clus_summary_df$col <- NA
clus_summary_df$col[clus_age<24] <- "red"
clus_summary_df$col[clus_age>24 & clus_age<48] <- "orange"
clus_summary_df$col[clus_age>48] <- "blue"



m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addPolylines(data = dat_shp, color = dat_shp$colours, weight=3,opacity=0.3, popup=dat_shp$name) %>% 
        addCircleMarkers(lng=clus_summary_df$g_c_location_long,
                         lat=clus_summary_df$g_c_location_lat, 
                         popup=paste("name"=clus_summary_df$trackId, 
                                     "<br>duration =",clus_summary_df$clus_dur_hr, "h", 
                                     "<br>time =",substr(clus_summary_df$clus_start, 12,16), "-", substr(clus_summary_df$clus_end, 12,16),
                                     "<br>npos =",clus_summary_df$n_clus_locs, " Radius =" ,clus_summary_df$clus_radius,"m",
                                     "<br>lon =" ,clus_summary_df$g_c_location_long  , "lat =", clus_summary_df$g_c_location_lat) 
                                     ,
                          fillOpacity = 0.3, opacity = 0.7, radius=4, color=clus_summary_df$col)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
      )  %>% 
    addLegend(position="topright", labels=c("<24", "24-48", "48+"), colors=c("red","orange","blue"), title="Cluster age")%>%
  addFullscreenControl()

m


```


# Roost and nest sites

The following map shows the locations where birds spend the night. 

**IMPORTANT** 

Roost = A bird temporarily spending a night at a location but moving frequently

Potential nest = A bird returning to the same location through time (across multiple days and weeks)

### Nighttime roost movement summary

If a birds night-time roost is does not change then the average roost spacing will be very low (<0.5 km - green rows). We should also look at the data where the average roost spacing is <1km (orange rows). All other rows are white:

```{r, eval=T, echo=F, warning=F, message=F}
sub_dat <- mov_dat[mov_dat$location_lat>0,]
# Remove the non-vultures
sub_dat <- sub_dat[sub_dat$name %in% animals$name[animals$taxon_canonical_name %in% c("Cathartes aura", "Sarcoramphus papa", "Cathartes melambrotus" )],]


# remove empty levels
sub_dat$name <- factor(sub_dat$name)


sub_dat_df <- as.data.frame(sub_dat)
sub_dat_df$id <- paste0(sub_dat_df$name,"_", substr(sub_dat_df$timestamp,1,10))
first_and_last <- sub_dat_df %>%
  group_by(id) %>%
  #arrange(stopSequence) %>%
  filter(row_number()==1 | row_number()==n())

#first_and_last[, c("name", "timestamp")]

# Create a night column -> where each unique night has its own ID
first_and_last$night_id <- paste0("n_", as.numeric(as.factor(substr(first_and_last$timestamp - hours(12),1,10))))
#first_and_last[, c("name", "timestamp", "night_id")]
# Great - remove n_1 as there should only be on observation



#hist(as.numeric(substr(sub_dat$timestamp, 12,13)), breaks=seq(3.5,23.5,1))
#hist(as.numeric(substr(night_dat$timestamp, 12,13)), breaks=seq(3.5,23.5,1))


#plot(night_dat)
#night_dat_df <- as.data.frame(night_dat)


#night_dat_df <- night_dat_df[order(night_dat_df$name),]
first_and_last <- first_and_last[order(first_and_last$name),]
#Convert from tibble
first_and_last <- as.data.frame(first_and_last)

lfc <- do.call(st_sfc,
              lapply(split(first_and_last, first_and_last$name),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
night_shp <- st_sf(data.frame(name=levels(factor(first_and_last[,"name"])), geom=lfc))

st_crs(night_shp) <- 4326

# Add the colours
cr_cols <- tmp_cr[, c("name", "colours")]
cr_cols <- cr_cols[duplicated(cr_cols)==F,]
cr_cols$name<- sub('\\_.*', '', cr_cols$name)

cr_cols$name <- as.character(cr_cols$name)

night_shp <- left_join(night_shp, cr_cols)

#night_dat_df <- left_join(night_dat_df, cr_cols, by=c("name"= "name"))
first_and_last <- left_join(first_and_last, cr_cols, by=c("name"= "name"))

tmp <- first_and_last %>% group_by(name) %>%  dplyr::summarise(nights=n_distinct(night_id))
night_shp <- left_join(night_shp, tmp, by=c("name"="name"))

night_shp$roost_spacing_km <- round(as.numeric((st_length(night_shp)/1000)/night_shp$nights),1)

night_shp_df <- as.data.frame(night_shp)
night_shp_df$geometry<- NULL

night_shp_df <- night_shp_df[,c("name", "roost_spacing_km"),]
night_shp_df <- night_shp_df[order(night_shp_df$roost_spacing_km),]

# Determine colours
night_shp_df$col <- "white"
night_shp_df$col[night_shp_df$roost_spacing_km<0.5] <- "#99d8c9"
night_shp_df$col[night_shp_df$roost_spacing_km>0.5 & night_shp_df$roost_spacing_km<1 ] <- "#ffeda0"

night_shp_df[,c("name", "roost_spacing_km")] %>%
  kbl(row.names = FALSE) %>%
  kable_styling()  %>% 
  column_spec(c(1,2), background = night_shp_df$col) %>%
  kableExtra::scroll_box(width = "100%")

```

You can see the distribution of the nightime locations with the following map.  Where: the points mark the first and last observations from each day, and the lines connect those points. Animals which are nesting will have a very tight cluster of points. 

```{r, eval=T, echo=F}
m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addPolylines(data = night_shp, color = night_shp$colours, weight=3,opacity=0.3, popup=night_shp$name, group=night_shp$name) %>% 
        addCircleMarkers(lng=first_and_last$location_long,
                         lat=first_and_last$location_lat, 
                         popup=paste("name"=first_and_last$name, "<br>Time = ", substr(first_and_last$timestamp,12,16), "Date = ",substr(first_and_last$timestamp,1,10),
                                  "<br>Lon = ", round(first_and_last$location_long,6), "Lat = ",round(first_and_last$location_lat,6)),
                         fillOpacity = 0.3, opacity = 0.7, radius=4, color=first_and_last$colours)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = night_shp$name,
        options = layersControlOptions(collapsed = FALSE)
      )%>%
  addFullscreenControl()  #%>%
     #addLegend(position= "topright", colors=night_shp$colours, 
      #          labels=night_shp$name ,opacity = 0.7, title = "Animals") 

  
m

# Not required

# # Clustering test
# 
# library(sp)
# library(rgdal)
# library(geosphere)
# 
# # example data from the thread
# x <- c(-1.482156, -1.482318, -1.482129, -1.482880, -1.485735, -1.485770, -1.485913, -1.484275, -1.485866)
# y <- c(54.90083, 54.90078, 54.90077, 54.90011, 54.89936, 54.89935, 54.89935, 54.89879, 54.89902)
# 
# # convert data to a SpatialPointsDataFrame object
# xy <- SpatialPointsDataFrame(
#       matrix(c(first_and_last$location_long,first_and_last$location_lat), ncol=2), data.frame(ID=seq(1:nrow(first_and_last))),
#       proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
# 
# # use the distm function to generate a geodesic distance matrix in meters
# mdist <- distm(xy)
# 
# # cluster all points using a hierarchical clustering approach
# hc <- hclust(as.dist(mdist), method="complete")
# 
# # define the distance threshold, in this case 40 m
# d=200
# 
# # define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
# xy$clust <- cutree(hc, h=d)
# first_and_last$clust_id <- xy$clust
# first_and_last$name
# 
# 
# 
# nest_res <- first_and_last %>% group_by(name) %>% summarise(nights=n_distinct(night_id), clusters=n_distinct(clust_id))
# nest_res$nest_index <- 1-(nest_res$clusters/nest_res$nights)
# library(amt)
# hr_area(laf_sf)
# 
# test <- first_and_last[first_and_last$name=="Attenborough",]
# 
# plot(test$location_long, test$location_lat, col=test$cust)
# 
# 
# 
# test <- first_and_last[first_and_last$name=="Frosty",]
# 
# plot(test$location_long, test$location_lat, col=test$cust)
# 
# 
# 
# #Aggregateing nights
# laf_sf <- st_as_sf(first_and_last, coords=c("location_long", "location_lat"), crs=4327)
# 
# pts_agg <- aggregate(laf_sf,
#                      by=list(laf_sf$id),
#                      FUN = mean,
#                      join = function(x, y))
# 
# 
# # I should merge the morning and night to make things easier
# 
# R1 <- laf_sf %>% aggregate(., 
#                 by = list(.$id), 
#                 function(x) x = x[1]) %>% 
#   st_centroid() %>% 
#   select(-Group.1)
# 
#   

```

# Heat maps

The following maps are heat maps of all of the data we have for certain individuals. Note, we do not do this for every individual as it would mean using a lot of bandwidth each time the report updates.

### Juancito

```{r}
#Tapir

tmp_tapir <- getMovebankData(study=1954804459, login=loginStored,  removeDuplicatedTimestamps=TRUE)
tmp <- tmp_tapir[["Juancito"]]

# Remove outliers
#plot(tmp)
tmp<- tmp[tmp$location_lat<8.75,]

# Transform to UTM
data2 <- spTransform(tmp, CRSobj="+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")
#plot(data2)

# Run brownian bridge
dbbmm <- brownian.bridge.dyn(object=data2, location.error=50, dimSize=500, ext=1,
time.step=2, margin=15)

# Check
#plot(dbbmm)

# Reproject for leaflet
test <- projectRaster(dbbmm, crs=crs("+proj=longlat +datum=WGS84 +no_defs"))
#plot(test)
# Filter out low probability locations
test[test<0.0001] <- NA
#plot(test)

# Make the numbers bigger for the leaflet legend to show (may not be required for other datasets)
test <- test*100

# Make the palette
tmp_pal <- c("#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2")


pal <- colorNumeric(rev(tmp_pal), values(test),
  na.color = "transparent")

# Create shapefiles
tmp_df <- as.data.frame(tmp)

# Costa rica
lfc <- do.call(st_sfc,
              lapply(split(tmp_df, tmp_df$local_identifier),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_shp <- st_sf(data.frame(name=levels(factor(tmp_df[,"local_identifier"])), geom=lfc))


leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addRasterImage(test, group="Raster", colors = pal, layerId="Raster") %>% 
  addPolylines(data=tmp_shp, color = "black",
               label = tmp_shp$NAME, group="Track",  weight=1, opacity = 0.3) %>%
   
   # addOpacitySlider(layerId = "Raster") %>%
  
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("Raster", "Track"),
    options = layersControlOptions(collapsed = FALSE)) %>%
  addLegend(pal = pal, values = values(test),
    title = "Time") %>%
  addFullscreenControl()     #%>%
  #addPolylines(data=tmp_lcp, weight = 2, fillColor = "blue",
   #            label = tmp_lcp$ID)# %>% 
  #addCircleMarkers(data=tmp_end, col="black", radius=1)


```

### Tuva

```{r}
#Tapir
tmp <- tmp_tapir[["Tuva"]]
  
# Remove outliers
#plot(tmp)
tmp<- tmp[tmp$location_lat<8.50,]
tmp<- tmp[tmp$location_lat>8,]
plot(tmp)
# Transform to UTM
data2 <- spTransform(tmp, CRSobj="+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")
#plot(data2)

# Run brownian bridge
dbbmm <- brownian.bridge.dyn(object=data2, location.error=50, dimSize=500, ext=1,
time.step=2, margin=5, window.size=13)
# Change margin and window size when you have more data

# Check
#plot(dbbmm)

# Reproject for leaflet
test <- projectRaster(dbbmm, crs=crs("+proj=longlat +datum=WGS84 +no_defs"))
#plot(test)
# Filter out low probability locations
test[test<0.0001] <- NA
#plot(test)

# Make the numbers bigger for the leaflet legend to show (may not be required for other datasets)
test <- test*100

# Make the palette
tmp_pal <- c("#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2")


pal <- colorNumeric(rev(tmp_pal), values(test),
  na.color = "transparent")

# Create shapefiles
tmp_df <- as.data.frame(tmp)

# Costa rica
lfc <- do.call(st_sfc,
              lapply(split(tmp_df, tmp_df$local_identifier),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_shp <- st_sf(data.frame(name=levels(factor(tmp_df[,"local_identifier"])), geom=lfc))


leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addRasterImage(test, group="Raster", colors = pal, layerId="Raster") %>% 
  addPolylines(data=tmp_shp, color = "black",
               label = tmp_shp$NAME, group="Track",  weight=1, opacity = 0.3) %>%
   
   # addOpacitySlider(layerId = "Raster") %>%
  
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("Raster", "Track"),
    options = layersControlOptions(collapsed = FALSE)) %>%
  addLegend(pal = pal, values = values(test),
    title = "Time")  %>%
  addFullscreenControl()    #%>%
  #addPolylines(data=tmp_lcp, weight = 2, fillColor = "blue",
   #            label = tmp_lcp$ID)# %>% 
  #addCircleMarkers(data=tmp_end, col="black", radius=1)


```



### Pardo

```{r}
# Create heatmaps using lifetime tracks

#OCelot
tmp <- getMovebankData(study=2526574641, login=loginStored,  removeDuplicatedTimestamps=TRUE)

# Remove outliers
#plot(tmp)
tmp<- tmp[tmp$location_lat<8.75,]

# Transform to UTM
data2 <- spTransform(tmp, CRSobj="+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")
#plot(data2)

# Run brownian bridge
dbbmm <- brownian.bridge.dyn(object=data2, location.error=50, dimSize=500, ext=1,
time.step=2, margin=15)

# Check
#plot(dbbmm)

# Reproject for leaflet
test <- projectRaster(dbbmm, crs=crs("+proj=longlat +datum=WGS84 +no_defs"))

# Filter out low probability locations
test[test<0.00003] <- NA
#plot(test)

# Make the numbers bigger for the leaflet legend to show (may not be required for other datasets)
test <- test*100

# Make the palette
tmp_pal <- c("#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2")


pal <- colorNumeric(rev(tmp_pal), values(test),
  na.color = "transparent")

# Create shapefiles
tmp_df <- as.data.frame(tmp)

# Costa rica
lfc <- do.call(st_sfc,
              lapply(split(tmp_df, tmp_df$local_identifier),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_shp <- st_sf(data.frame(name=levels(factor(tmp_df[,"local_identifier"])), geom=lfc))


leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addPolylines(data=tmp_shp, color = "black",
               label = tmp_shp$NAME, group="Track",  weight=1, opacity = 0.3) %>%
  addRasterImage(test, group="Raster", colors = pal, layerId="Raster") %>% 

   
   # addOpacitySlider(layerId = "Raster") %>%
  
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c( "Track","Raster"),
    options = layersControlOptions(collapsed = FALSE)) %>%
  addLegend(pal = pal, values = values(test),
    title = "Time")   %>%
  addFullscreenControl()   


?addLayersControl
```

# Interactions

Coming soon!


```{r, eval=F}
library(wildlifeDI)

# Vultures
mov_dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)
tmp <- mov_dat[[c("Attenborough", "Elvis")]]

tmp$timestamp <- with_tz(timestamps(tmp), tz="America/Costa_Rica")

#UTM
tmp <- spTransform(tmp,CRSobj="+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")

int_dat <- as(tmp,"ltraj")

#plot(int_dat)
plt <- dcPlot(int_dat,tc=15*60,dmax=1000)

doecons <- conProcess(int_dat,dc=200,tc=15*60)  
doephas <- conPhase(doecons, pc=60*60)
conSummary(doephas)

doepair <- conPairs(doephas)
doetemp <- conTemporal(doephas,units='mins')

doepair$hod <- as.POSIXlt(doepair$date)$hour + as.POSIXlt(doepair$date)$min / 60  #convert POSIX to hours
doetemp$hod <- as.POSIXlt(doetemp$start_time)$hour + as.POSIXlt(doetemp$start_time)$min / 60  #convert POSIX to hours
doepair$dom <- as.POSIXlt(doepair$date)$mday
hist(doepair$dom,breaks=0:31)

hist(doepair$hod,breaks=0:24) #Figure 2b
# turn all fixes into points 
sf_pt <- ltraj2sf(int_dat)
con_sf <- conSpatial(doephas,type='point')             # Get points of all contacts

#Figure 3a
sf_pt <- ltraj2sf(does)  # Turn all fixes into sf points
plot(st_geometry(sf_pt),col='grey',pch=20)
plot(st_geometry(con_sf),col='black',pch=20,add=T)

#Figure 3b
con_sf_first <- conSpatial(doephas,type='point',def='first')

plot(st_geometry(sf_pt),col='grey',pch=20)
plot(st_geometry(con_sf),col='black',pch=20,add=T)
plot(st_geometry(con_sf_first),col='red',pch=20,add=T)

con_sf_ln <- conSpatial(doephas,type='line')
st_crs(con_sf_ln) <- "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs"
con_sf_ln <- st_transform(con_sf_ln, 4326)
sf_ln <- ltraj2sf(int_dat,type='line')  # Turn all fixes into sf points
st_crs(sf_ln) <- "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs"
sf_ln <- st_transform(sf_ln, 4326)

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
m %>% 
addPolylines(data = sf_ln, color = c("red", "black"), weight=1,opacity=0.3) %>% 
addPolylines(data = con_sf_ln, color = c("blue"), weight=2,opacity=0.3) %>%
  
      #addLegend(position= "topright", colors=tmp_cr_shp$colours, 
       #         labels=names ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        #overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 


  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_shp[i,], color = tmp_cr_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_cr$location_long[tmp_cr$name==ids[i]],
                         lat=tmp_cr$location_lat[tmp_cr$name==ids[i]], 
                         popup=paste(tmp_cr$timestamp[tmp_cr$name==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$name==ids[i]]), 
                         popup=paste(last(tmp_cr$timestamp[tmp_cr$name==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>% 
        # Add the last point
        addMarkers(lng=last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$name==ids[i]]), 
                         popup=paste(last(tmp_cr$local_identifier[tmp_cr$name==ids[i]]),
                                     "<br>Time:",last(tmp_cr$timestamp[tmp_cr$name==ids[i]]),
                                     "<br>Long:",last(tmp_cr$location_long[tmp_cr$name==ids[i]]),
                                     "<br>Lat:",last(tmp_cr$location_lat[tmp_cr$name==ids[i]])),
                   icon = iconSet[tmp_cr$icon[tmp_cr$name==ids[i]][1]], group=ids[i]) #, fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F
    }

  m <- m %>%
      #addLegend(position= "topright", colors=tmp_cr_shp$colours, 
       #         labels=names ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()
  
m 

```


# Hardware function and settings

The following plots track how the tags are performing in the field. 

###  Battery status
Average battery level (last 14 days):

```{r, echo=F, warning=FALSE}
cols<- c("#fc8d59", "#99d594")

fig <- plot_ly(check_in_summary, x = ~name, y = ~mean_batt, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Battery power",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


###  Location accuracy 

Average horizontal location accuracy (last 14 days):

```{r, echo=F, warning=F}
fig <- plot_ly(check_in_summary, x = ~name, y = ~loc_accuracy, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Location accuracy (m)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


### Reporting frequencies

Average number of locations per day (last 14 days):

```{r, echo=F}
#colnames(check_in_summary)

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$name))


fig <- plot_ly(check_in_summary, x = ~name, y = ~locs_per_day, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='y')

fig <- fig %>% layout(title = "Locations per day",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "", hoverformat = '.1f'))


 
fig
```

### Temporal activity
*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_cr$name))


fig <- plot_ly(x = tmp_cr$timestamp, y = tmp_cr$name,type="scatter",
               height=1000, text=tmp_cr$name, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

By the hour:

```{r}
dat$hour <- ymd_h(substr(dat$timestamp, 1,13))
tmp <- dat %>% group_by(local_identifier, hour) %>% summarise(freq=n())

# Subset to just last 14
tmp <- tmp[tmp$hour>start_t,]



col.cat <- turbo(length(unique(dat[,"local_identifier"])))


cols <- col.cat[1:length(unique(dat$local_identifier))]



fig <- plot_ly(tmp, x = ~hour, y = ~freq, name = tmp$local_identifier, type = 'scatter', mode = 'lines',split = ~local_identifier,color=~local_identifier, colors=cols) 

fig <- fig %>%  layout(title = "Average hourly locations (last 14 days)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Locations per hour"))

fig

#individual plots

# i <- 33
# for(i in 1:length(unique(dat$local_identifier)))
# {
#   tmp2 <- tmp[tmp$local_identifier==unique(dat$local_identifier)[i],]
# 
# fig <- plot_ly(tmp2, x = ~hour, y = ~freq, name = tmp2$local_identifier, type = 'scatter', mode = 'lines',split = ~local_identifier,color=~local_identifier, colors=cols,
#                text=paste(tmp2$local_identifier, tmp2$hour), hoverinfo='text') 
# 
# fig <- fig %>%  layout(title = "Average hourly locations (last 14 days)",
#                       xaxis = xform,
#                       xaxis = list(title = ""),
#                       yaxis = list(title = "Locations per hour"))
# 
# fig
# }




```




*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_peru$name))


fig <- plot_ly(x = tmp_peru$timestamp, y = tmp_peru$name,type="scatter",
               height=1000, text=tmp_peru$name, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

